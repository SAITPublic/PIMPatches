From 397825367ca9202fc2c62ab7467a51bea14a7959 Mon Sep 17 00:00:00 2001
From: Mike Kashkarov <fruitclover@gmail.com>
Date: Fri, 3 Jun 2022 21:48:09 +0900
Subject: [PATCH 1/2] Pim directives base support: parsing, AST, PFT

- [mlir] Add prototype for pim dialect

    Skeleton all convertion and translation pathes, describe basic pim operation
    suitable for PIMLibrary usage: pim.add, pim.mul, device ininialization and
    destruction, buffer usage

    Example mlir with pim ops:

      module {
        llvm.func @test_parallel(%in1: memref<16xf16>, %in2: memref<16xf16>, %result: memref<16xf16>) {
          pim.parallel {
            %result = pim.sum %in1, %in1 : memref<16xf16>
            pim.yield
          }
          llvm.return
        }
      }

- [flang] Add prototype for pim PFT, AST and parsing

    Add directive parsing, AST and PFT language support, basic lowering with
    operation patterns for futher lowering in LLVM IR with mlir tranlsations.

    Example for:

      subroutine sub1(a, b, c, n)
        real :: a(:), b(:), c(:)
        integer :: n, i
        i = 0
        !$pim parallel loop copyin(a, b) copyout(c)
        do i = 1, n
          c(i) = a(i) + b(i)
        end do
      end subroutine

    produce AST:

      | | ExecutionPartConstruct -> ExecutableConstruct -> PimConstruct -> PimCombinedConstruct
      | | | PimBeginCombinedDirective
      | | | | PimCombinedDirective -> llvm::pim::Directive = parallel loop
      | | | | PimClauseList -> PimClause -> Copyin -> PimObjectListWithModifier
      | | | | | PimObjectList -> PimObject -> Designator -> DataRef -> Name = 'a'
      | | | | | PimObject -> Designator -> DataRef -> Name = 'b'
      | | | | PimClause -> Copyout -> PimObjectListWithModifier
      | | | | | PimObjectList -> PimObject -> Designator -> DataRef -> Name = 'c'
      | | | DoConstruct

    and pre-fir tree (PFT):

      1 Subroutine sub1: subroutine sub1(a, b, c, n)
         1 AssignmentStmt: i = 0
         2 <<PimConstruct>>
           <<DoConstruct>> -> 6
             3 NonLabelDoStmt -> 5: do i = 1, n
             4 ^PimOperationStmt: c(i) = a(i) + b(i)
             5 EndDoStmt -> 3: end do
           <<End DoConstruct>>
           6 ContinueStmt
         <<End PimConstruct>>
         7 EndSubroutineStmt: end subroutine
       End Subroutine sub1

      }

- [llvm] Add prototype for pim directive language and IR builder

    Add directive parsing, AST and PFT language support, basic lowering with
    operation patterns for futher lowering in LLVM IR with mlir tranlsations.

    Example for:

      module {
        llvm.func @test_parallel(%in1: f16, %result: f16) {
          pim.parallel {
            %result_1 = pim.sum %in1, %in1 : f16
            pim.yield
          }
          llvm.return
        }
      }

    IR builder generates calls to PIMLibrary (PimInitialize, PimExecuteAdd, PimDeinitialize):

      define void @test_parallel(ptr %input1, ptr %input2, ptr %result) !dbg !3 {
        br label %pim.init

      pim.init:                                         ; preds = %2
        %upper.bound = alloca i32, align 4
        store i32 1, ptr %upper.bound, align 4
        %3 = call i32 @PimInitialize(i32 0, i32 0)
        %4 = icmp ne i32 %3, 0
        br i1 %4, label %pim.init.PimInitialize.success, label %pim.init.PimInitialize.fail

      pim.init.PimInitialize.success:                   ; preds = %pim.init
        br label %pim.body

      pim.init.PimInitialize.fail:                      ; preds = %pim.init
        %5 = call i32 (ptr, ...) @printf(ptr @0, ptr @1)
        unreachable

      pim.body:                                         ; preds = %pim.init.PimInitialize.success
        %6 = call i32 @PimExecuteAdd(ptr %result, ptr %input1, ptr %input2, ptr null, i1 false)
        %7 = icmp ne i32 %6, 0
        br i1 %7, label %pim.body.PimExecuteAdd.success, label %pim.body.PimExecuteAdd.fail

      pim.body.PimExecuteAdd.success:                   ; preds = %pim.body
        br label %pim.deinit

      pim.body.PimExecuteAdd.fail:                      ; preds = %pim.body
        %8 = call i32 (ptr, ...) @printf(ptr @2, ptr @3)
        unreachable

      pim.deinit:                                       ; preds = %pim.body.PimExecuteAdd.success
        %9 = call i32 @PimDeinitialize()
        %10 = icmp ne i32 %9, 0
        br i1 %10, label %pim.deinit.PimDeinitialize.success, label %pim.deinit.PimDeinitialize.fail

      pim.deinit.PimDeinitialize.success:               ; preds = %pim.deinit
        ret void, !dbg !7

      pim.deinit.PimDeinitialize.fail:                  ; preds = %pim.deinit
        %11 = call i32 (ptr, ...) @printf(ptr @4, ptr @5)
        unreachable
      }
---
 clang/include/clang/Driver/Options.td         |   2 +
 flang/examples/FlangOmpReport/CMakeLists.txt  |   1 +
 .../PrintFlangFunctionNames/CMakeLists.txt    |   1 +
 flang/include/flang/Common/Fortran-features.h |   5 +-
 flang/include/flang/Lower/PFTBuilder.h        |   5 +-
 flang/include/flang/Lower/Pim.h               |  51 +
 .../include/flang/Optimizer/Support/InitFIR.h |   4 +-
 .../flang/Optimizer/Transforms/Passes.h       |   3 +
 .../flang/Optimizer/Transforms/Passes.td      |   9 +
 flang/include/flang/Parser/dump-parse-tree.h  |  37 +
 flang/include/flang/Parser/parse-tree.h       | 179 +++-
 flang/include/flang/Tools/CLOptions.inc       |   1 +
 flang/lib/Evaluate/CMakeLists.txt             |   1 +
 flang/lib/Frontend/CMakeLists.txt             |   1 +
 flang/lib/Frontend/CompilerInvocation.cpp     |  10 +
 flang/lib/Lower/Bridge.cpp                    |  73 ++
 flang/lib/Lower/CMakeLists.txt                |   1 +
 flang/lib/Lower/PFTBuilder.cpp                |   1 +
 flang/lib/Lower/Pim.cpp                       | 899 ++++++++++++++++++
 flang/lib/Optimizer/CodeGen/CMakeLists.txt    |   1 +
 flang/lib/Optimizer/CodeGen/CodeGen.cpp       |  10 +-
 flang/lib/Optimizer/CodeGen/PassDetail.h      |   1 +
 flang/lib/Optimizer/Dialect/CMakeLists.txt    |   1 +
 flang/lib/Optimizer/Support/CMakeLists.txt    |   1 +
 flang/lib/Optimizer/Transforms/CMakeLists.txt |   3 +
 .../Transforms/PimDataOperandConversion.cpp   | 125 +++
 flang/lib/Parser/CMakeLists.txt               |   3 +
 flang/lib/Parser/executable-parsers.cpp       |   2 +
 flang/lib/Parser/parsing.cpp                  |   4 +
 flang/lib/Parser/pim-parsers.cpp              | 224 +++++
 flang/lib/Parser/type-parsers.h               |   3 +
 flang/lib/Parser/unparse.cpp                  | 102 +-
 flang/lib/Semantics/CMakeLists.txt            |   3 +
 flang/lib/Semantics/canonicalize-do.cpp       |   1 +
 flang/lib/Semantics/canonicalize-pim.cpp      | 417 ++++++++
 flang/lib/Semantics/canonicalize-pim.h        |  21 +
 flang/lib/Semantics/check-pim-structure.h     |  48 +
 flang/lib/Semantics/resolve-directives.cpp    |  22 +
 flang/lib/Semantics/resolve-directives.h      |   1 +
 flang/lib/Semantics/resolve-names.cpp         |   1 +
 flang/lib/Semantics/semantics.cpp             |   3 +
 flang/test/Driver/driver-help-hidden.f90      |   1 +
 flang/test/Driver/driver-help.f90             |   2 +
 flang/test/Lower/Pim/pre-fir-tree01.f90       |  46 +
 flang/test/Lower/Pim/pre-fir-tree02.f90       |  52 +
 flang/tools/bbc/bbc.cpp                       |  10 +
 flang/tools/f18-parse-demo/CMakeLists.txt     |   1 +
 flang/tools/f18/CMakeLists.txt                |   1 +
 llvm/include/llvm/Frontend/CMakeLists.txt     |   1 +
 llvm/include/llvm/Frontend/Pim/CMakeLists.txt |   4 +
 llvm/include/llvm/Frontend/Pim/PIM.td         | 109 +++
 llvm/include/llvm/Frontend/Pim/PIMIRBuilder.h | 166 ++++
 llvm/include/llvm/Frontend/Pim/PIMOps.td      |  51 +
 llvm/lib/Frontend/CMakeLists.txt              |   1 +
 llvm/lib/Frontend/Pim/CMakeLists.txt          |  23 +
 llvm/lib/Frontend/Pim/PIM.cpp                 |  19 +
 llvm/lib/Frontend/Pim/PIMIRBuilder.cpp        | 392 ++++++++
 mlir/include/mlir/Conversion/Passes.h         |   1 +
 mlir/include/mlir/Conversion/Passes.td        |  10 +
 .../Conversion/PimToLLVM/ConvertPimToLLVM.h   |  33 +
 mlir/include/mlir/Dialect/CMakeLists.txt      |   1 +
 mlir/include/mlir/Dialect/Pim/CMakeLists.txt  |  47 +
 mlir/include/mlir/Dialect/Pim/Pim.h           |  52 +
 mlir/include/mlir/Dialect/Pim/PimDialect.h    |  35 +
 mlir/include/mlir/Dialect/Pim/PimOps.td       | 287 ++++++
 .../mlir/Dialect/Pim/PimOpsInterfaces.td      |  48 +
 .../mlir/Dialect/Pim/PimTypeInterfaces.td     |  31 +
 mlir/include/mlir/InitAllDialects.h           |   2 +
 mlir/include/mlir/Target/LLVMIR/Dialect/All.h |   2 +
 .../Dialect/Pim/PimToLLVMIRTranslation.h      |  31 +
 .../mlir/Target/LLVMIR/ModuleTranslation.h    |  15 +
 mlir/lib/Conversion/CMakeLists.txt            |   1 +
 mlir/lib/Conversion/PimToLLVM/CMakeLists.txt  |  23 +
 mlir/lib/Conversion/PimToLLVM/PimToLLVM.cpp   | 127 +++
 mlir/lib/Dialect/CMakeLists.txt               |   1 +
 mlir/lib/Dialect/Pim/CMakeLists.txt           |  15 +
 mlir/lib/Dialect/Pim/IR/Pim.cpp               | 287 ++++++
 mlir/lib/Target/LLVMIR/CMakeLists.txt         |   2 +
 mlir/lib/Target/LLVMIR/Dialect/CMakeLists.txt |   1 +
 .../Target/LLVMIR/Dialect/Pim/CMakeLists.txt  |  13 +
 .../Dialect/Pim/PimToLLVMIRTranslation.cpp    |  98 ++
 mlir/lib/Target/LLVMIR/ModuleTranslation.cpp  |   1 +
 82 files changed, 4309 insertions(+), 15 deletions(-)
 create mode 100644 flang/include/flang/Lower/Pim.h
 create mode 100644 flang/lib/Lower/Pim.cpp
 create mode 100644 flang/lib/Optimizer/Transforms/PimDataOperandConversion.cpp
 create mode 100644 flang/lib/Parser/pim-parsers.cpp
 create mode 100644 flang/lib/Semantics/canonicalize-pim.cpp
 create mode 100644 flang/lib/Semantics/canonicalize-pim.h
 create mode 100644 flang/lib/Semantics/check-pim-structure.h
 create mode 100644 flang/test/Lower/Pim/pre-fir-tree01.f90
 create mode 100644 flang/test/Lower/Pim/pre-fir-tree02.f90
 create mode 100644 llvm/include/llvm/Frontend/Pim/CMakeLists.txt
 create mode 100644 llvm/include/llvm/Frontend/Pim/PIM.td
 create mode 100644 llvm/include/llvm/Frontend/Pim/PIMIRBuilder.h
 create mode 100644 llvm/include/llvm/Frontend/Pim/PIMOps.td
 create mode 100644 llvm/lib/Frontend/Pim/CMakeLists.txt
 create mode 100644 llvm/lib/Frontend/Pim/PIM.cpp
 create mode 100644 llvm/lib/Frontend/Pim/PIMIRBuilder.cpp
 create mode 100644 mlir/include/mlir/Conversion/PimToLLVM/ConvertPimToLLVM.h
 create mode 100644 mlir/include/mlir/Dialect/Pim/CMakeLists.txt
 create mode 100644 mlir/include/mlir/Dialect/Pim/Pim.h
 create mode 100644 mlir/include/mlir/Dialect/Pim/PimDialect.h
 create mode 100644 mlir/include/mlir/Dialect/Pim/PimOps.td
 create mode 100644 mlir/include/mlir/Dialect/Pim/PimOpsInterfaces.td
 create mode 100644 mlir/include/mlir/Dialect/Pim/PimTypeInterfaces.td
 create mode 100644 mlir/include/mlir/Target/LLVMIR/Dialect/Pim/PimToLLVMIRTranslation.h
 create mode 100644 mlir/lib/Conversion/PimToLLVM/CMakeLists.txt
 create mode 100644 mlir/lib/Conversion/PimToLLVM/PimToLLVM.cpp
 create mode 100644 mlir/lib/Dialect/Pim/CMakeLists.txt
 create mode 100644 mlir/lib/Dialect/Pim/IR/Pim.cpp
 create mode 100644 mlir/lib/Target/LLVMIR/Dialect/Pim/CMakeLists.txt
 create mode 100644 mlir/lib/Target/LLVMIR/Dialect/Pim/PimToLLVMIRTranslation.cpp

diff --git a/clang/include/clang/Driver/Options.td b/clang/include/clang/Driver/Options.td
index 8c9901d086ee..9bd989e23c87 100644
--- a/clang/include/clang/Driver/Options.td
+++ b/clang/include/clang/Driver/Options.td
@@ -4896,6 +4896,8 @@ file}]>;
 def ffixed_line_length_VALUE : Joined<["-"], "ffixed-line-length-">, Group<f_Group>, Alias<ffixed_line_length_EQ>;
 def fopenacc : Flag<["-"], "fopenacc">, Group<f_Group>,
   HelpText<"Enable OpenACC">;
+def fpim : Flag<["-"], "fpim">, Group<f_Group>,
+  HelpText<"Enable Pim">;
 def fdefault_double_8 : Flag<["-"],"fdefault-double-8">, Group<f_Group>,
   HelpText<"Set the default double precision kind to an 8 byte wide type">;
 def fdefault_integer_8 : Flag<["-"],"fdefault-integer-8">, Group<f_Group>,
diff --git a/flang/examples/FlangOmpReport/CMakeLists.txt b/flang/examples/FlangOmpReport/CMakeLists.txt
index aebebe92d6b3..9cc555bb2aa7 100644
--- a/flang/examples/FlangOmpReport/CMakeLists.txt
+++ b/flang/examples/FlangOmpReport/CMakeLists.txt
@@ -6,4 +6,5 @@ add_llvm_library(flangOmpReport
   DEPENDS
   acc_gen
   omp_gen
+  pim_gen
 )
diff --git a/flang/examples/PrintFlangFunctionNames/CMakeLists.txt b/flang/examples/PrintFlangFunctionNames/CMakeLists.txt
index 490f2ea89516..87b5e0a62f2b 100644
--- a/flang/examples/PrintFlangFunctionNames/CMakeLists.txt
+++ b/flang/examples/PrintFlangFunctionNames/CMakeLists.txt
@@ -7,4 +7,5 @@ add_llvm_library(flangPrintFunctionNames
     DEPENDS
     acc_gen
     omp_gen
+    pim_gen
 )
diff --git a/flang/include/flang/Common/Fortran-features.h b/flang/include/flang/Common/Fortran-features.h
index 2411e7cd0293..4e4b28afa967 100644
--- a/flang/include/flang/Common/Fortran-features.h
+++ b/flang/include/flang/Common/Fortran-features.h
@@ -25,7 +25,7 @@ ENUM_CLASS(LanguageFeature, BackslashEscapes, OldDebugLines,
     SignedPrimary, FileName, Carriagecontrol, Convert, Dispose,
     IOListLeadingComma, AbbreviatedEditDescriptor, ProgramParentheses,
     PercentRefAndVal, OmitFunctionDummies, CrayPointer, Hollerith, ArithmeticIF,
-    Assign, AssignedGOTO, Pause, OpenACC, OpenMP, CruftAfterAmpersand,
+    Assign, AssignedGOTO, Pause, OpenACC, OpenMP, Pim, CruftAfterAmpersand,
     ClassicCComments, AdditionalFormats, BigIntLiterals, RealDoControls,
     EquivalenceNumericWithCharacter, EquivalenceNonDefaultNumeric,
     EquivalenceSameNonSequence, AdditionalIntrinsics, AnonymousParents,
@@ -42,6 +42,7 @@ public:
     // These features must be explicitly enabled by command line options.
     disable_.set(LanguageFeature::OldDebugLines);
     disable_.set(LanguageFeature::OpenACC);
+    disable_.set(LanguageFeature::Pim);
     disable_.set(LanguageFeature::OpenMP);
     disable_.set(LanguageFeature::ImplicitNoneTypeNever);
     disable_.set(LanguageFeature::ImplicitNoneTypeAlways);
@@ -60,7 +61,7 @@ public:
   bool IsEnabled(LanguageFeature f) const { return !disable_.test(f); }
   bool ShouldWarn(LanguageFeature f) const {
     return (warnAll_ && f != LanguageFeature::OpenMP &&
-               f != LanguageFeature::OpenACC) ||
+               f != LanguageFeature::OpenACC && f != LanguageFeature::Pim) ||
         warn_.test(f);
   }
   // Return all spellings of operators names, depending on features enabled
diff --git a/flang/include/flang/Lower/PFTBuilder.h b/flang/include/flang/Lower/PFTBuilder.h
index 933d50a0c015..6134929e05ce 100644
--- a/flang/include/flang/Lower/PFTBuilder.h
+++ b/flang/include/flang/Lower/PFTBuilder.h
@@ -137,7 +137,8 @@ using Constructs =
 using Directives =
     std::tuple<parser::CompilerDirective, parser::OpenACCConstruct,
                parser::OpenACCDeclarativeConstruct, parser::OpenMPConstruct,
-               parser::OpenMPDeclarativeConstruct, parser::OmpEndLoopDirective>;
+               parser::OpenMPDeclarativeConstruct, parser::OmpEndLoopDirective,
+               parser::PimConstruct>;
 
 using DeclConstructs = std::tuple<parser::OpenMPDeclarativeConstruct,
                                   parser::OpenACCDeclarativeConstruct>;
@@ -177,7 +178,7 @@ static constexpr bool isNopConstructStmt{common::HasMember<
 template <typename A>
 static constexpr bool isExecutableDirective{common::HasMember<
     A, std::tuple<parser::CompilerDirective, parser::OpenACCConstruct,
-                  parser::OpenMPConstruct>>};
+                  parser::OpenMPConstruct, parser::PimConstruct>>};
 
 template <typename A>
 static constexpr bool isFunctionLike{common::HasMember<
diff --git a/flang/include/flang/Lower/Pim.h b/flang/include/flang/Lower/Pim.h
new file mode 100644
index 000000000000..15d20bc9fe09
--- /dev/null
+++ b/flang/include/flang/Lower/Pim.h
@@ -0,0 +1,51 @@
+//===-- Lower/Pim.h -- lower Pim directives ---------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// Coding style: https://mlir.llvm.org/getting_started/DeveloperGuide/
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef FORTRAN_LOWER_PIM_H
+#define FORTRAN_LOWER_PIM_H
+
+#include "flang/Parser/parse-tree.h"
+namespace Fortran {
+namespace parser {
+struct PimConstruct;
+struct PimDeclarativeConstruct;
+} // namespace parser
+
+namespace semantics {
+class SemanticsContext;
+}
+
+namespace lower {
+
+class AbstractConverter;
+
+namespace pft {
+struct Evaluation;
+} // namespace pft
+
+
+void genPimConstruct(
+    AbstractConverter &converter,
+    Fortran::semantics::SemanticsContext &semanticsContext,
+    pft::Evaluation &eval,
+    const parser::PimConstruct &pimConstruct);
+void genPimOperations(AbstractConverter &, pft::Evaluation &,
+                     const parser::PimOperation &);
+void genPimOperations(AbstractConverter &, pft::Evaluation &,
+                     const parser::PimConstruct &);
+void genPimDeclarativeConstruct(AbstractConverter &, pft::Evaluation &,
+                                const parser::PimDeclarativeConstruct &);
+
+} // namespace lower
+} // namespace Fortran
+
+#endif // FORTRAN_LOWER_PIM_H
diff --git a/flang/include/flang/Optimizer/Support/InitFIR.h b/flang/include/flang/Optimizer/Support/InitFIR.h
index 9b3b6311db99..c1ae402fc5cf 100644
--- a/flang/include/flang/Optimizer/Support/InitFIR.h
+++ b/flang/include/flang/Optimizer/Support/InitFIR.h
@@ -21,12 +21,14 @@
 #include "mlir/Pass/PassRegistry.h"
 #include "mlir/Transforms/LocationSnapshot.h"
 #include "mlir/Transforms/Passes.h"
+// TODO(mike): quick WA, fix with proper cmake dep
+// #include "mlir/Dialect/Pim/PimOpsDialect.h.inc"
 
 namespace fir::support {
 
 #define FLANG_NONCODEGEN_DIALECT_LIST                                          \
   mlir::AffineDialect, FIROpsDialect, mlir::acc::OpenACCDialect,               \
-      mlir::omp::OpenMPDialect, mlir::scf::SCFDialect,                         \
+      mlir::omp::OpenMPDialect, mlir::pim::PimDialect, mlir::scf::SCFDialect,  \
       mlir::arith::ArithmeticDialect, mlir::cf::ControlFlowDialect,            \
       mlir::func::FuncDialect, mlir::vector::VectorDialect,                    \
       mlir::math::MathDialect
diff --git a/flang/include/flang/Optimizer/Transforms/Passes.h b/flang/include/flang/Optimizer/Transforms/Passes.h
index 2835f3e310cd..e9c01297f671 100644
--- a/flang/include/flang/Optimizer/Transforms/Passes.h
+++ b/flang/include/flang/Optimizer/Transforms/Passes.h
@@ -46,6 +46,9 @@ std::unique_ptr<mlir::Pass> createAlgebraicSimplificationPass();
 std::unique_ptr<mlir::Pass>
 createAlgebraicSimplificationPass(const mlir::GreedyRewriteConfig &config);
 
+// Pim-related passes
+std::unique_ptr<mlir::Pass> createPimDataOperandConversionPass();
+
 // declarative passes
 #define GEN_PASS_REGISTRATION
 #include "flang/Optimizer/Transforms/Passes.h.inc"
diff --git a/flang/include/flang/Optimizer/Transforms/Passes.td b/flang/include/flang/Optimizer/Transforms/Passes.td
index cb0df9cd630c..122388396880 100644
--- a/flang/include/flang/Optimizer/Transforms/Passes.td
+++ b/flang/include/flang/Optimizer/Transforms/Passes.td
@@ -233,4 +233,13 @@ def AlgebraicSimplification : Pass<"flang-algebraic-simplification"> {
   let constructor = "::fir::createAlgebraicSimplificationPass()";
 }
 
+def PimFirDataConversion : Pass<"pim-data-conversion", "mlir::ModuleOp"> {
+  let summary = "Convert Pim data operand to mlir types";
+  let description = [{
+    Convert PIm data operand to mlir types for runtime calls with PIMLibrary.
+  }];
+  let constructor = "::fir::createPimDataOperandConversionPass()";
+  let dependentDialects = [ "fir::FIROpsDialect", "mlir::LLVM::LLVMDialect" ];
+}
+
 #endif // FLANG_OPTIMIZER_TRANSFORMS_PASSES
diff --git a/flang/include/flang/Parser/dump-parse-tree.h b/flang/include/flang/Parser/dump-parse-tree.h
index e0f8a0d63240..2b634eef1b42 100644
--- a/flang/include/flang/Parser/dump-parse-tree.h
+++ b/flang/include/flang/Parser/dump-parse-tree.h
@@ -73,6 +73,43 @@ public:
         "llvm::acc::DefaultValue = ", llvm::acc::getOpenACCDefaultValueName(x))
         .str();
   }
+#define GEN_FLANG_DUMP_PARSE_TREE_CLAUSES
+#include "llvm/Frontend/Pim/PIM.inc"
+  NODE(parser, PimObject)
+  NODE(parser, PimObjectList)
+  NODE(parser, PimDataModifier)
+  NODE_ENUM(parser::PimDataModifier, Modifier)
+  NODE(parser, PimObjectListWithModifier)
+  NODE(parser, PimConstruct)
+  NODE(parser, PimLoopDirective)
+  NODE(parser, PimLoopConstruct)
+  NODE(parser, PimBeginLoopDirective)
+  NODE(parser, PimRoutineConstruct)
+  NODE(parser, PimBeginBlockDirective)
+  NODE(parser, PimEndBlockDirective)
+  NODE(parser, PimDefaultClause)
+  NODE(parser, PimClause)
+  NODE(parser, PimClauseList)
+  NODE(parser, PimBlockDirective)
+  NODE(parser, PimBlockConstruct)
+  NODE(parser, PimCombinedDirective)
+  NODE(parser, PimBeginCombinedDirective)
+  NODE(parser, PimEndCombinedDirective)
+  NODE(parser, PimCombinedConstruct)
+  NODE(parser, PimAdd)
+  NODE(parser, PimMul)
+  NODE(parser, PimOperation)
+  static std::string GetNodeName(const llvm::pim::DefaultValue &x) {
+    return llvm::Twine(
+        "llvm::pim::DefaultValue = ", llvm::pim::getPIMDefaultValueName(x))
+        .str();
+  }
+  static std::string GetNodeName(const llvm::pim::Directive &x) {
+    return llvm::Twine(
+        "llvm::pim::Directive = ", llvm::pim::getPIMDirectiveName(x))
+        .str();
+  }
+
   NODE(parser, AccClauseList)
   NODE(parser, AccCombinedDirective)
   NODE(parser, AccDataModifier)
diff --git a/flang/include/flang/Parser/parse-tree.h b/flang/include/flang/Parser/parse-tree.h
index 17cee660cbc0..65fd720d667b 100644
--- a/flang/include/flang/Parser/parse-tree.h
+++ b/flang/include/flang/Parser/parse-tree.h
@@ -27,6 +27,7 @@
 #include "flang/Common/indirection.h"
 #include "llvm/Frontend/OpenACC/ACC.h.inc"
 #include "llvm/Frontend/OpenMP/OMPConstants.h"
+#include "llvm/Frontend/Pim/PIM.h.inc"
 #include <cinttypes>
 #include <list>
 #include <memory>
@@ -260,6 +261,9 @@ struct AssignedGotoStmt;
 struct PauseStmt;
 struct OpenACCConstruct;
 struct AccEndCombinedDirective;
+struct PimOperation;
+struct PimConstruct;
+struct PimEndCombinedDirective;
 struct OpenACCDeclarativeConstruct;
 struct OpenMPConstruct;
 struct OpenMPDeclarativeConstruct;
@@ -511,7 +515,7 @@ struct ExecutableConstruct {
   std::variant<Statement<ActionStmt>, common::Indirection<AssociateConstruct>,
       common::Indirection<BlockConstruct>, common::Indirection<CaseConstruct>,
       common::Indirection<ChangeTeamConstruct>,
-      common::Indirection<CriticalConstruct>,
+      common::Indirection<CriticalConstruct>, common::Indirection<PimOperation>,
       Statement<common::Indirection<LabelDoStmt>>,
       Statement<common::Indirection<EndDoStmt>>,
       common::Indirection<DoConstruct>, common::Indirection<IfConstruct>,
@@ -521,6 +525,8 @@ struct ExecutableConstruct {
       common::Indirection<CompilerDirective>,
       common::Indirection<OpenACCConstruct>,
       common::Indirection<AccEndCombinedDirective>,
+      common::Indirection<PimConstruct>,
+      common::Indirection<PimEndCombinedDirective>,
       common::Indirection<OpenMPConstruct>,
       common::Indirection<OmpEndLoopDirective>>
       u;
@@ -2665,10 +2671,10 @@ struct ReadStmt {
       : iounit{std::move(i)}, format{std::move(f)}, controls(std::move(cs)),
         items(std::move(its)) {}
   std::optional<IoUnit> iounit; // if first in controls without UNIT= &/or
-                                // followed by untagged format/namelist
+  // followed by untagged format/namelist
   std::optional<Format> format; // if second in controls without FMT=/NML=, or
-                                // no (io-control-spec-list); might be
-                                // an untagged namelist group name
+  // no (io-control-spec-list); might be
+  // an untagged namelist group name
   std::list<IoControlSpec> controls;
   std::list<InputItem> items;
 };
@@ -2687,9 +2693,9 @@ struct WriteStmt {
       : iounit{std::move(i)}, format{std::move(f)}, controls(std::move(cs)),
         items(std::move(its)) {}
   std::optional<IoUnit> iounit; // if first in controls without UNIT= &/or
-                                // followed by untagged format/namelist
+  // followed by untagged format/namelist
   std::optional<Format> format; // if second in controls without FMT=/NML=;
-                                // might be an untagged namelist group, too
+  // might be an untagged namelist group, too
   std::list<IoControlSpec> controls;
   std::list<OutputItem> items;
 };
@@ -4123,5 +4129,166 @@ struct OpenACCConstruct {
       u;
 };
 
+// PIM
+struct PimClause;
+struct PimBlockDirective;
+struct PimClauseList;
+struct PimLoopDirective;
+struct PimBeginLoopDirective;
+struct PimBeginBlockDirective;
+struct PimEndBlockDirective;
+struct PimLoopConstruct;
+struct PimRoutineConstruct;
+struct PimBlockConstruct;
+struct PimConstruct;
+struct PimDefaultClause;
+struct PimCombinedDirective;
+struct PimBeginCombinedDirective;
+struct PimEndCombinedDirective;
+struct PimCombinedConstruct;
+
+struct PimAdd;
+struct PimMul;
+// struct PimRelu;
+// struct PimGemv;
+
+
+struct PimAdd {
+  TUPLE_CLASS_BOILERPLATE(PimAdd);
+  std::tuple<Variable, Expr> t;
+};
+
+struct PimMul {
+  TUPLE_CLASS_BOILERPLATE(PimMul);
+  std::tuple<Variable, Expr> t;
+};
+
+struct PimOperation {
+  UNION_CLASS_BOILERPLATE(PimOperation);
+  std::variant<PimAdd, PimMul> u;
+};
+
+struct PimObject {
+  UNION_CLASS_BOILERPLATE(PimObject);
+  std::variant<Designator, /*common block*/ Name> u;
+};
+
+WRAPPER_CLASS(PimObjectList, std::list<PimObject>);
+
+struct PimDataModifier {
+  ENUM_CLASS(Modifier, ReadOnly, Zero)
+  WRAPPER_CLASS_BOILERPLATE(PimDataModifier, Modifier);
+  CharBlock source;
+};
+
+struct PimObjectListWithModifier {
+  TUPLE_CLASS_BOILERPLATE(PimObjectListWithModifier);
+  std::tuple<std::optional<PimDataModifier>, PimObjectList> t;
+};
+
+// PIM directive beginning or ending a block
+struct PimBlockDirective {
+  WRAPPER_CLASS_BOILERPLATE(PimBlockDirective, llvm::pim::Directive);
+  CharBlock source;
+};
+
+struct PimClauseList {
+  WRAPPER_CLASS_BOILERPLATE(PimClauseList, std::list<PimClause>);
+  CharBlock source;
+};
+
+struct PimLoopDirective {
+  WRAPPER_CLASS_BOILERPLATE(PimLoopDirective, llvm::pim::Directive);
+  CharBlock source;
+};
+
+struct PimBeginLoopDirective {
+  TUPLE_CLASS_BOILERPLATE(PimBeginLoopDirective);
+  std::tuple<PimLoopDirective, PimClauseList> t;
+  CharBlock source;
+};
+
+struct PimBeginBlockDirective {
+  TUPLE_CLASS_BOILERPLATE(PimBeginBlockDirective);
+  CharBlock source;
+  std::tuple<PimBlockDirective, PimClauseList> t;
+};
+
+struct PimEndBlockDirective {
+  TUPLE_CLASS_BOILERPLATE(PimEndBlockDirective);
+  std::tuple<PimBlockDirective, PimClauseList> t;
+  CharBlock source;
+};
+
+struct PimLoopConstruct {
+  TUPLE_CLASS_BOILERPLATE(PimLoopConstruct);
+  PimLoopConstruct(PimBeginLoopDirective &&a)
+      : t({std::move(a), std::nullopt}) {}
+  std::tuple<PimBeginLoopDirective, std::optional<DoConstruct>> t;
+};
+
+struct PimRoutineConstruct {
+  TUPLE_CLASS_BOILERPLATE(PimRoutineConstruct);
+  CharBlock source;
+  std::tuple<Verbatim, std::optional<Name>, PimClauseList> t;
+};
+
+struct PimBlockConstruct {
+  TUPLE_CLASS_BOILERPLATE(PimBlockConstruct);
+  std::tuple<PimBeginBlockDirective, Block, PimEndBlockDirective> t;
+};
+
+struct PimCombinedDirective {
+  WRAPPER_CLASS_BOILERPLATE(PimCombinedDirective, llvm::pim::Directive);
+  CharBlock source;
+};
+
+struct PimEndCombinedDirective {
+  WRAPPER_CLASS_BOILERPLATE(PimEndCombinedDirective, PimCombinedDirective);
+  CharBlock source;
+};
+
+struct PimBeginCombinedDirective {
+  TUPLE_CLASS_BOILERPLATE(PimBeginCombinedDirective);
+  CharBlock source;
+  std::tuple<PimCombinedDirective, PimClauseList> t;
+};
+
+struct PimCombinedConstruct {
+  TUPLE_CLASS_BOILERPLATE(PimCombinedConstruct);
+  CharBlock source;
+  PimCombinedConstruct(PimBeginCombinedDirective &&a)
+      : t({std::move(a), std::nullopt, std::nullopt}) {}
+  std::tuple<PimBeginCombinedDirective, std::optional<DoConstruct>,
+      std::optional<PimEndCombinedDirective>>
+      t;
+};
+
+struct PimConstruct {
+  UNION_CLASS_BOILERPLATE(PimConstruct);
+  std::variant<PimBlockConstruct, PimCombinedConstruct, PimLoopConstruct> u;
+};
+
+struct PimDefaultClause {
+  WRAPPER_CLASS_BOILERPLATE(PimDefaultClause, llvm::pim::DefaultValue);
+  CharBlock source;
+};
+
+struct PimClause {
+  UNION_CLASS_BOILERPLATE(PimClause);
+
+#define GEN_FLANG_CLAUSE_PARSER_CLASSES
+#include "llvm/Frontend/Pim/PIM.inc"
+
+  CharBlock source;
+
+  std::variant<
+#define GEN_FLANG_CLAUSE_PARSER_CLASSES_LIST
+#include "llvm/Frontend/Pim/PIM.inc"
+      >
+      u;
+};
+
+
 } // namespace Fortran::parser
 #endif // FORTRAN_PARSER_PARSE_TREE_H_
diff --git a/flang/include/flang/Tools/CLOptions.inc b/flang/include/flang/Tools/CLOptions.inc
index 97bdddbfc38a..3112de89d316 100644
--- a/flang/include/flang/Tools/CLOptions.inc
+++ b/flang/include/flang/Tools/CLOptions.inc
@@ -196,6 +196,7 @@ inline void createDefaultFIRCodeGenPassPipeline(mlir::PassManager &pm) {
   fir::addCodeGenRewritePass(pm);
   fir::addTargetRewritePass(pm);
   fir::addExternalNameConversionPass(pm);
+  addPass(fir::createPimDataOperandConversionPass());
   fir::addFIRToLLVMPass(pm);
 }
 
diff --git a/flang/lib/Evaluate/CMakeLists.txt b/flang/lib/Evaluate/CMakeLists.txt
index 7195edc3c0e5..33df35b35cb4 100644
--- a/flang/lib/Evaluate/CMakeLists.txt
+++ b/flang/lib/Evaluate/CMakeLists.txt
@@ -62,4 +62,5 @@ add_flang_library(FortranEvaluate
   DEPENDS
   acc_gen
   omp_gen
+  pim_gen
 )
diff --git a/flang/lib/Frontend/CMakeLists.txt b/flang/lib/Frontend/CMakeLists.txt
index 96769c707f10..f012213b8292 100644
--- a/flang/lib/Frontend/CMakeLists.txt
+++ b/flang/lib/Frontend/CMakeLists.txt
@@ -47,4 +47,5 @@ add_flang_library(flangFrontend
   Target
   FrontendOpenACC
   FrontendOpenMP
+  FrontendPIM
 )
diff --git a/flang/lib/Frontend/CompilerInvocation.cpp b/flang/lib/Frontend/CompilerInvocation.cpp
index a75c04d5962e..554f826d35a0 100644
--- a/flang/lib/Frontend/CompilerInvocation.cpp
+++ b/flang/lib/Frontend/CompilerInvocation.cpp
@@ -580,6 +580,10 @@ static bool parseDialectArgs(CompilerInvocation &res, llvm::opt::ArgList &args,
     res.getFrontendOpts().features.Enable(
         Fortran::common::LanguageFeature::OpenMP);
   }
+  if (args.hasArg(clang::driver::options::OPT_fpim)) {
+    res.getFrontendOpts().features.Enable(
+        Fortran::common::LanguageFeature::Pim);
+  }
 
   // -pedantic
   if (args.hasArg(clang::driver::options::OPT_pedantic)) {
@@ -729,6 +733,12 @@ void CompilerInvocation::setDefaultPredefinitions() {
           Fortran::common::LanguageFeature::OpenMP)) {
     fortranOptions.predefinitions.emplace_back("_OPENMP", "201511");
   }
+
+  if (frontendOptions.features.IsEnabled(
+          Fortran::common::LanguageFeature::Pim)) {
+    fortranOptions.predefinitions.emplace_back("__pim__", "1");
+  }
+
 }
 
 void CompilerInvocation::setFortranOpts() {
diff --git a/flang/lib/Lower/Bridge.cpp b/flang/lib/Lower/Bridge.cpp
index 521782125de8..2d948b5826a4 100644
--- a/flang/lib/Lower/Bridge.cpp
+++ b/flang/lib/Lower/Bridge.cpp
@@ -23,6 +23,7 @@
 #include "flang/Lower/Mangler.h"
 #include "flang/Lower/OpenACC.h"
 #include "flang/Lower/OpenMP.h"
+#include "flang/Lower/Pim.h"
 #include "flang/Lower/PFTBuilder.h"
 #include "flang/Lower/Runtime.h"
 #include "flang/Lower/StatementContext.h"
@@ -1093,6 +1094,7 @@ private:
     bool unstructuredContext = eval.lowerAsUnstructured();
     Fortran::lower::pft::Evaluation &doStmtEval =
         eval.getFirstNestedEvaluation();
+
     auto *doStmt = doStmtEval.getIf<Fortran::parser::NonLabelDoStmt>();
     const auto &loopControl =
         std::get<std::optional<Fortran::parser::LoopControl>>(doStmt->t);
@@ -2478,6 +2480,7 @@ private:
   }
 
   void genFIR(const Fortran::parser::AssignmentStmt &stmt) {
+    LLVM_DEBUG(llvm::dbgs() << "[void genFIR(const Fortran::parser::AssignmentStmt &stmt)]\n");
     genAssignment(*stmt.typedAssignment->v);
   }
 
@@ -2599,6 +2602,76 @@ private:
     TODO(toLocation(), "NamelistStmt lowering");
   }
 
+
+  void genFIR(const Fortran::parser::PimOperation &op) {
+    genPimOperations(*this, getEval(), op);
+  }
+
+  void genFIR(const Fortran::parser::PimOperation *) {
+      TODO(toLocation(), "implement *");
+  }
+
+  void genFIR(const Fortran::parser::PimConstruct &pc) {
+    LLVM_DEBUG(llvm::dbgs()
+               << "[void genFIR(const Fortran::parser::PimConstruct &pc)]\n");
+    mlir::OpBuilder::InsertPoint insertPt = builder->saveInsertionPoint();
+    // localSymbols.pushScope();
+
+    genPimConstruct(*this, bridge.getSemanticsContext(), getEval(), pc);
+    genPimOperations(*this, getEval(), pc);
+
+    // Fortran::lower::pft::Evaluation &doStmtEval =
+    //     eval.getFirstNestedEvaluation();
+    // auto *doStmt = doStmtEval.getIf<Fortran::parser::NonLabelDoStmt>();
+
+    // Fortran::lower::pft::Evaluation &doStmtEval =
+    //     eval.getFirstNestedEvaluation();
+    // auto *doStmt = doStmtEval.getIf<Fortran::parser::NonLabelDoStmt>();
+
+    for (Fortran::lower::pft::Evaluation &e :
+         getEval().getNestedEvaluations()) {
+      if (auto *doConstructStmt = e.getIf<Fortran::parser::DoConstruct>()) {
+        LLVM_DEBUG(llvm::dbgs() << "Found expected DoConstruct for pim, should "
+                                   "assert if smth else\n");
+        auto &doBlock = std::get<Fortran::parser::Block>(doConstructStmt->t);
+        for (auto &elem : doBlock) {
+            if (auto *pimOp{Fortran::parser::Unwrap<Fortran::parser::PimOperation>(elem)}) {
+                LLVM_DEBUG(llvm::dbgs() << "--> BRIDGE PimOperation in block\n");
+                genFIR(*pimOp);
+            }
+          LLVM_DEBUG(llvm::dbgs() << "--> Something in block\n");
+        }
+      }
+
+      // Fortran::lower::pft::Evaluation &eval = getEval();
+      // bool unstructuredContext = eval.lowerAsUnstructured();
+      // Fortran::lower::pft::Evaluation &doStmtEval =
+      //     eval.getFirstNestedEvaluation();
+      // auto *doStmt = doStmtEval.getIf<Fortran::parser::NonLabelDoStmt>();
+      // const auto &loopControl =
+      //     std::get<std::optional<Fortran::parser::LoopControl>>(doStmt->t);
+      // mlir::Block *preheaderBlock = doStmtEval.block;
+      // mlir::Block *beginBlock =
+      //     preheaderBlock ? preheaderBlock : builder->getBlock();
+      // auto createNextBeginBlock = [&]() {
+      // for (Fortran::lower::pft::Evaluation &e :
+      //      getEval().getNestedEvaluations()) {
+      // }
+      if (auto *assignmentStmt = e.getIf<Fortran::parser::AssignmentStmt>()) {
+        const Fortran::evaluate::Assignment &assign =
+            *assignmentStmt->typedAssignment->v;
+        LLVM_DEBUG(assign.lhs.AsFortran(llvm::dbgs() << "PIM candidate array: ")
+                       << '\n';
+                   assign.rhs.AsFortran(llvm::dbgs() << "assign expression: "));
+      }
+      // genFIR(e);
+    }
+    // genPimOperations(*this, getEval(), pc);
+
+    // localSymbols.popScope();
+    builder->restoreInsertionPoint(insertPt);
+  }
+
   /// Generate FIR for the Evaluation `eval`.
   void genFIR(Fortran::lower::pft::Evaluation &eval,
               bool unstructuredContext = true) {
diff --git a/flang/lib/Lower/CMakeLists.txt b/flang/lib/Lower/CMakeLists.txt
index 2874084e7e55..ac5b55696abb 100644
--- a/flang/lib/Lower/CMakeLists.txt
+++ b/flang/lib/Lower/CMakeLists.txt
@@ -18,6 +18,7 @@ add_flang_library(FortranLower
   Mangler.cpp
   OpenACC.cpp
   OpenMP.cpp
+  Pim.cpp
   PFTBuilder.cpp
   Runtime.cpp
   SymbolMap.cpp
diff --git a/flang/lib/Lower/PFTBuilder.cpp b/flang/lib/Lower/PFTBuilder.cpp
index 16cfde1e0214..96ede4ff3fa1 100644
--- a/flang/lib/Lower/PFTBuilder.cpp
+++ b/flang/lib/Lower/PFTBuilder.cpp
@@ -336,6 +336,7 @@ private:
     if (eval->isExecutableDirective()) {
       // A construct at the end of an (unstructured) OpenACC or OpenMP
       // construct region must have an exit target inside the region.
+      // Apply the same requirement for Pim directives also.
       Fortran::lower::pft::EvaluationList &evaluationList =
           *eval->evaluationList;
       if (!evaluationList.empty() && evaluationList.back().isConstruct()) {
diff --git a/flang/lib/Lower/Pim.cpp b/flang/lib/Lower/Pim.cpp
new file mode 100644
index 000000000000..4e138d9bccba
--- /dev/null
+++ b/flang/lib/Lower/Pim.cpp
@@ -0,0 +1,899 @@
+//===-- Pim.cpp -- Pim directive lowering ---------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// Coding style: https://mlir.llvm.org/getting_started/DeveloperGuide/
+//
+//===----------------------------------------------------------------------===//
+
+#include "flang/Lower/Pim.h"
+#include "flang/Common/idioms.h"
+#include "flang/Evaluate/tools.h"
+#include "flang/Lower/Bridge.h"
+#include "flang/Lower/PFTBuilder.h"
+#include "flang/Lower/StatementContext.h"
+#include "flang/Optimizer/Builder/BoxValue.h"
+#include "flang/Optimizer/Builder/FIRBuilder.h"
+#include "flang/Optimizer/Builder/Todo.h"
+#include "flang/Parser/parse-tree.h"
+#include "flang/Semantics/tools.h"
+#include "mlir/Dialect/Pim/Pim.h"
+#include "llvm/Frontend/Pim/PIM.h.inc"
+#include "llvm/Support/Debug.h" // llvm::dbgs()
+
+#include "flang/Lower/ConvertExpr.h"
+
+
+
+#define DEBUG_TYPE "pim-lower"
+
+
+static const Fortran::parser::Name *
+getDesignatorNameIfDataRef(const Fortran::parser::Designator &designator) {
+  const auto *dataRef = std::get_if<Fortran::parser::DataRef>(&designator.u);
+  return dataRef ? std::get_if<Fortran::parser::Name>(&dataRef->u) : nullptr;
+}
+
+static mlir::Type getLoopVarType(Fortran::lower::AbstractConverter &converter,
+                                 std::size_t loopVarTypeSize) {
+  // OpenMP runtime requires 32-bit or 64-bit loop variables.
+  loopVarTypeSize = loopVarTypeSize * 8;
+  if (loopVarTypeSize < 32) {
+    loopVarTypeSize = 32;
+  } else if (loopVarTypeSize > 64) {
+    loopVarTypeSize = 64;
+    mlir::emitWarning(converter.getCurrentLocation(),
+                      "PIM loop iteration variable cannot have more than 64 "
+                      "bits size and will be narrowed into 64 bits.");
+  }
+  assert((loopVarTypeSize == 32 || loopVarTypeSize == 64) &&
+         "PIm loop iteration variable size must be transformed into 32-bit "
+         "or 64-bit");
+  return converter.getFirOpBuilder().getIntegerType(loopVarTypeSize);
+}
+
+static void createEmptyRegionBlocks(
+    fir::FirOpBuilder &firOpBuilder,
+    std::list<Fortran::lower::pft::Evaluation> &evaluationList) {
+  auto *region = &firOpBuilder.getRegion();
+  for (auto &eval : evaluationList) {
+    if (eval.block) {
+      if (eval.block->empty()) {
+        eval.block->erase();
+        eval.block = firOpBuilder.createBlock(region);
+      } else {
+        [[maybe_unused]] auto &terminatorOp = eval.block->back();
+        assert(
+               // (mlir::isa<mlir::pim::TerminatorOp>(terminatorOp) ||
+                mlir::isa<mlir::pim::YieldOp>(terminatorOp)
+                // )
+               &&
+               "expected terminator op");
+      }
+    }
+    if (!eval.isDirective() && eval.hasNestedEvaluations())
+      createEmptyRegionBlocks(firOpBuilder, eval.getNestedEvaluations());
+  }
+}
+
+static void resetBeforeTerminator(fir::FirOpBuilder &firOpBuilder,
+                           mlir::Operation *storeOp, mlir::Block &block) {
+  if (storeOp)
+    firOpBuilder.setInsertionPointAfter(storeOp);
+  else
+    firOpBuilder.setInsertionPointToStart(&block);
+}
+
+static Fortran::semantics::Symbol *
+getPimObjectSymbol(const Fortran::parser::PimObject &ompObject) {
+  Fortran::semantics::Symbol *sym = nullptr;
+  std::visit(Fortran::common::visitors{
+                 [&](const Fortran::parser::Designator &designator) {
+                   if (const Fortran::parser::Name *name =
+                           getDesignatorNameIfDataRef(designator)) {
+                     sym = name->symbol;
+                   }
+                 },
+                 [&](const Fortran::parser::Name &name) { sym = name.symbol; }},
+             ompObject.u);
+  return sym;
+}
+
+template <typename Op>
+static bool privatizeVars(Op &op, Fortran::lower::AbstractConverter &converter,
+                          const Fortran::parser::PimClauseList &opClauseList,
+                          Fortran::lower::pft::Evaluation &eval) {
+  LLVM_DEBUG(llvm::dbgs() << "PIM privatizeVars\n");
+  fir::FirOpBuilder &firOpBuilder = converter.getFirOpBuilder();
+  auto insPt = firOpBuilder.saveInsertionPoint();
+  firOpBuilder.setInsertionPointToStart(firOpBuilder.getAllocaBlock());
+  bool hasFirstPrivateOp = false;
+  bool hasLastPrivateOp = false;
+  // Symbols in private and/or firstprivate clauses.
+  llvm::SetVector<const Fortran::semantics::Symbol *> privatizedSymbols;
+  auto collectPimObjectListSymbol =
+      [&](const Fortran::parser::PimObjectList &pimObjectList,
+          llvm::SetVector<const Fortran::semantics::Symbol *> &symbolSet) {
+        for (const Fortran::parser::PimObject &pimObject : pimObjectList.v) {
+          Fortran::semantics::Symbol *sym = getPimObjectSymbol(pimObject);
+          symbolSet.insert(sym);
+        }
+      };
+  // We need just one ICmpOp for multiple LastPrivate clauses.
+  mlir::arith::CmpIOp cmpOp;
+
+  for (const Fortran::parser::PimClause &clause : opClauseList.v) {
+      // collectPimObjectListSymbol(clause->v, privatizedSymbols);
+    if (const auto &privateClause =
+            std::get_if<Fortran::parser::PimClause::Copyin>(&clause.u)) {
+      collectPimObjectListSymbol(privateClause->v, privatizedSymbols);
+    } else if (const auto &firstPrivateClause =
+                   std::get_if<Fortran::parser::PimClause::Copyout>(
+                       &clause.u)) {
+      collectPimObjectListSymbol(firstPrivateClause->v, privatizedSymbols);
+      hasFirstPrivateOp = true;
+    } else if (const auto &lastPrivateClause =
+                   std::get_if<Fortran::parser::PimClause::Copy>(
+                       &clause.u)) {
+      // TODO: Add lastprivate support for sections construct, simd construct
+      // if (std::is_same_v<Op, mlir::pim::ParallelOp>) {
+      //   mlir::pim::ParallelOp *wsLoopOp = llvm::dyn_cast<mlir::pim::ParallelOp>(&op);
+      //   fir::FirOpBuilder &firOpBuilder = converter.getFirOpBuilder();
+      //   auto insPt = firOpBuilder.saveInsertionPoint();
+
+      //   // Our goal here is to introduce the following control flow
+      //   // just before exiting the worksharing loop.
+      //   // Say our wsloop is as follows:
+      //   //
+      //   // pim.wsloop {
+      //   //    ...
+      //   //    store
+      //   //    omp.yield
+      //   // }
+      //   //
+      //   // We want to convert it to the following:
+      //   //
+      //   // omp.wsloop {
+      //   //    ...
+      //   //    store
+      //   //    %cmp = llvm.icmp "eq" %iv %ub
+      //   //    scf.if %cmp {
+      //   //      ^%lpv_update_blk:
+      //   //    }
+      //   //    omp.yield
+      //   // }
+
+      //   mlir::Operation *lastOper = wsLoopOp->region().back().getTerminator();
+
+      //   firOpBuilder.setInsertionPoint(lastOper);
+
+      //   // // TODO: The following will not work when there is collapse present.
+      //   // // Have to modify this in future.
+      //   // for (const Fortran::parser::PimClause &clause : opClauseList.v)
+      //   //   if (const auto &collapseClause =
+      //   //           std::get_if<Fortran::parser::OmpClause::Collapse>(&clause.u))
+      //   //     TODO(converter.getCurrentLocation(),
+      //   //          "Collapse clause with lastprivate");
+      //   // Only generate the compare once in presence of multiple LastPrivate
+      //   // clauses
+      //   // if (!hasLastPrivateOp) {
+      //   //   cmpOp = firOpBuilder.create<mlir::arith::CmpIOp>(
+      //   //       wsLoopOp->getLoc(), mlir::arith::CmpIPredicate::eq,
+      //   //       wsLoopOp->getRegion().front().getArguments()[0],
+      //   //       wsLoopOp->upperBound()[0]);
+      //   // }
+      //   // mlir::scf::IfOp ifOp = firOpBuilder.create<mlir::scf::IfOp>(
+      //   //     wsLoopOp->getLoc(), cmpOp, /*else*/ false);
+
+      //   firOpBuilder.restoreInsertionPoint(insPt);
+      //   // createPrivateVarSyms(converter, lastPrivateClause,
+      //   //                      &(ifOp.getThenRegion().front()));
+      // } else {
+      //   TODO(converter.getCurrentLocation(),
+      //        "lastprivate clause in constructs other than work-share loop");
+      // }
+      hasLastPrivateOp = true;
+    }
+  }
+
+  // Symbols in regions with default(private/firstprivate) clause.
+  // FIXME: Collect the symbols with private/firstprivate flag in the region of
+  // the construct with default(private/firstprivate) clause excluding the
+  // symbols with the same private/firstprivate flag in the inner nested
+  // regions.
+  llvm::SetVector<const Fortran::semantics::Symbol *> defaultSymbols;
+  llvm::SetVector<const Fortran::semantics::Symbol *> symbolsInNestedRegions;
+  llvm::SetVector<const Fortran::semantics::Symbol *> symbolsInParentRegions;
+  auto collectSymbols = [&](Fortran::semantics::Symbol::Flag flag) {
+    converter.collectSymbolSet(eval, defaultSymbols, flag,
+                               /*collectSymbols=*/true,
+                               /*collectHostAssociatedSymbols=*/true);
+    for (auto &e : eval.getNestedEvaluations()) {
+      if (e.hasNestedEvaluations())
+        converter.collectSymbolSet(e, symbolsInNestedRegions, flag,
+                                   /*collectSymbols=*/true,
+                                   /*collectHostAssociatedSymbols=*/false);
+      else
+        converter.collectSymbolSet(e, symbolsInParentRegions, flag,
+                                   /*collectSymbols=*/false,
+                                   /*collectHostAssociatedSymbols=*/true);
+    }
+  };
+
+  // for (const Fortran::parser::OmpClause &clause : opClauseList.v) {
+  //   if (const auto &defaultClause =
+  //           std::get_if<Fortran::parser::OmpClause::Default>(&clause.u)) {
+  //     if (defaultClause->v.v ==
+  //         Fortran::parser::OmpDefaultClause::Type::Private)
+  //       collectSymbols(Fortran::semantics::Symbol::Flag::OmpPrivate);
+  //     else if (defaultClause->v.v ==
+  //              Fortran::parser::OmpDefaultClause::Type::Firstprivate)
+  //       collectSymbols(Fortran::semantics::Symbol::Flag::OmpFirstPrivate);
+  //   }
+  // }
+
+  auto privatizeSymbol = [&](const Fortran::semantics::Symbol *sym) {
+    // Privatization for symbols which are pre-determined (like loop index
+    // variables) happen separately, for everything else privatize here.
+    if (sym->test(Fortran::semantics::Symbol::Flag::OmpPreDetermined))
+      return;
+    bool success = converter.createHostAssociateVarClone(*sym);
+    (void)success;
+    assert(success && "Privatization failed due to existing binding");
+    if (sym->test(Fortran::semantics::Symbol::Flag::OmpFirstPrivate)) {
+      converter.copyHostAssociateVar(*sym);
+      hasFirstPrivateOp = true;
+    }
+  };
+
+  // for (auto sym : privatizedSymbols)
+  //   privatizeSymbol(sym);
+
+  // for (auto sym : defaultSymbols)
+  //   if (!symbolsInNestedRegions.contains(sym) &&
+  //       !symbolsInParentRegions.contains(sym) &&
+  //       !privatizedSymbols.contains(sym))
+  //     privatizeSymbol(sym);
+
+  // if (hasFirstPrivateOp)
+  //   firOpBuilder.create<mlir::omp::BarrierOp>(converter.getCurrentLocation());
+  firOpBuilder.restoreInsertionPoint(insPt);
+  return hasLastPrivateOp;
+}
+
+
+static void
+genCopyinClause(Fortran::lower::AbstractConverter &converter,
+                const Fortran::parser::PimClauseList &opClauseList) {
+  fir::FirOpBuilder &firOpBuilder = converter.getFirOpBuilder();
+  mlir::OpBuilder::InsertPoint insPt = firOpBuilder.saveInsertionPoint();
+  firOpBuilder.setInsertionPointToStart(firOpBuilder.getAllocaBlock());
+  bool hasCopyin = false;
+  for (const Fortran::parser::PimClause &clause : opClauseList.v) {
+    if (const auto &copyinClause =
+            std::get_if<Fortran::parser::PimClause::Copyin>(&clause.u)) {
+      hasCopyin = true;
+      const Fortran::parser::PimObjectList &pimObjectList = copyinClause->v;
+      for (const Fortran::parser::PimObject &pimObject : pimObjectList.v) {
+        Fortran::semantics::Symbol *sym = getPimObjectSymbol(pimObject);
+        if (sym->has<Fortran::semantics::CommonBlockDetails>())
+          TODO(converter.getCurrentLocation(), "common block in Copyin clause");
+        if (Fortran::semantics::IsAllocatableOrPointer(sym->GetUltimate()))
+          TODO(converter.getCurrentLocation(),
+               "pointer or allocatable variables in Copyin clause");
+        assert(sym->has<Fortran::semantics::HostAssocDetails>() &&
+               "No host-association found");
+        converter.copyHostAssociateVar(*sym);
+      }
+    }
+  }
+  // [PIM 5.0, 2.19.6.1] The copy is done after the team is formed and prior to
+  // the execution of the associated structured block. Emit implicit barrier to
+  // synchronize threads and avoid data races on propagation master's thread
+  // values of threadprivate variables to local instances of that variables of
+  // all other implicit threads.
+  // if (hasCopyin)
+  //   firOpBuilder.create<mlir::pim::BarrierOp>(converter.getCurrentLocation());
+  firOpBuilder.restoreInsertionPoint(insPt);
+}
+
+
+template <typename Op>
+static void
+createBodyOfOp(Op &op, Fortran::lower::AbstractConverter &converter,
+               mlir::Location &loc, Fortran::lower::pft::Evaluation &eval,
+               llvm::SmallVectorImpl<int32_t> &operandSegments,
+               const Fortran::parser::PimClauseList *clauses = nullptr,
+               const llvm::SmallVector<const Fortran::semantics::Symbol *> &args = {},
+               bool outerCombined = false) {
+  fir::FirOpBuilder &firOpBuilder = converter.getFirOpBuilder();
+  // If an argument for the region is provided then create the block with that
+  // argument. Also update the symbol's address with the mlir argument value.
+  // e.g. For loops the argument is the induction variable. And all further
+  // uses of the induction variable should use this mlir value.
+  mlir::Operation *storeOp = nullptr;
+  if (args.size()) {
+    std::size_t loopVarTypeSize = 0;
+    for (const Fortran::semantics::Symbol *arg : args)
+      loopVarTypeSize = std::max(loopVarTypeSize, arg->GetUltimate().size());
+    mlir::Type loopVarType = getLoopVarType(converter, loopVarTypeSize);
+    llvm::SmallVector<mlir::Type> tiv;
+    llvm::SmallVector<mlir::Location> locs;
+    for (int i = 0; i < (int)args.size(); i++) {
+      tiv.push_back(loopVarType);
+      locs.push_back(loc);
+    }
+    firOpBuilder.createBlock(&op.getRegion(), {}, tiv, locs);
+    int argIndex = 0;
+    // The argument is not currently in memory, so make a temporary for the
+    // argument, and store it there, then bind that location to the argument.
+    for (const Fortran::semantics::Symbol *arg : args) {
+      mlir::Value val =
+          fir::getBase(op.getRegion().front().getArgument(argIndex));
+      mlir::Value temp = firOpBuilder.createTemporary(
+          loc, loopVarType,
+          llvm::ArrayRef<mlir::NamedAttribute>{
+              Fortran::lower::getAdaptToByRefAttr(firOpBuilder)});
+      storeOp = firOpBuilder.create<fir::StoreOp>(loc, val, temp);
+      converter.bindSymbol(*arg, temp);
+      argIndex++;
+    }
+  } else {
+    firOpBuilder.createBlock(&op.getRegion());
+  }
+  // Set the insert for the terminator operation to go at the end of the
+  // block - this is either empty or the block with the stores above,
+  // the end of the block works for both.
+  mlir::Block &block = op.getRegion().back();
+  firOpBuilder.setInsertionPointToEnd(&block);
+
+  // If it is an unstructured region and is not the outer region of a combined
+  // construct, create empty blocks for all evaluations.
+  if (eval.lowerAsUnstructured() && !outerCombined)
+    createEmptyRegionBlocks(firOpBuilder, eval.getNestedEvaluations());
+
+  // // Insert the terminator.
+  // if constexpr (std::is_same_v<Op, omp::WsLoopOp> ||
+  //               std::is_same_v<Op, omp::SimdLoopOp>) {
+  //   mlir::ValueRange results;
+  //   firOpBuilder.create<mlir::omp::YieldOp>(loc, results);
+  // } else {
+  //   firOpBuilder.create<mlir::omp::TerminatorOp>(loc);
+  // }
+
+  // Reset the insert point to before the terminator.
+  resetBeforeTerminator(firOpBuilder, storeOp, block);
+
+  // Handle privatization. Do not privatize if this is the outer operation.
+  if (clauses && !outerCombined) {
+    bool lastPrivateOp = privatizeVars(op, converter, *clauses, eval);
+    // LastPrivatization, due to introduction of
+    // new control flow, changes the insertion point,
+    // thus restore it.
+    // TODO: Clean up later a bit to avoid this many sets and resets.
+    if (lastPrivateOp)
+      resetBeforeTerminator(firOpBuilder, storeOp, block);
+  }
+
+  if constexpr (std::is_same_v<Op, mlir::pim::ParallelOp>) {
+    // threadPrivatizeVars(converter, eval);
+    // if (clauses)
+    //   genCopyinClause(converter, *clauses);
+  }
+
+  firOpBuilder.create<mlir::pim::YieldOp>(loc);
+
+  op->setAttr(Op::getOperandSegmentSizeAttr(),
+              firOpBuilder.getDenseI32ArrayAttr(operandSegments));
+
+  // Place the insertion point to the start of the first block.
+  firOpBuilder.setInsertionPointToStart(&block);
+}
+
+
+template <typename Op, typename Terminator>
+static Op
+createRegionOp(fir::FirOpBuilder &builder, mlir::Location loc,
+               const llvm::SmallVectorImpl<mlir::Value> &operands,
+               const llvm::SmallVectorImpl<int32_t> &operandSegments) {
+  llvm::ArrayRef<mlir::Type> argTy;
+  Op op = builder.create<Op>(loc, argTy, operands);
+  builder.createBlock(&op.getRegion());
+  mlir::Block &block = op.getRegion().back();
+  builder.setInsertionPointToStart(&block);
+  builder.create<Terminator>(loc);
+
+  op->setAttr(Op::getOperandSegmentSizeAttr(),
+              builder.getDenseI32ArrayAttr(operandSegments));
+
+  // Place the insertion point to the start of the first block.
+  builder.setInsertionPointToStart(&block);
+
+  return op;
+}
+
+static void genObjectList(const Fortran::parser::PimObjectList &objectList,
+                          Fortran::lower::AbstractConverter &converter,
+                          llvm::SmallVectorImpl<mlir::Value> &operands) {
+  auto addOperands = [&](Fortran::lower::SymbolRef sym) {
+    const auto variable = converter.getSymbolAddress(sym);
+    // TODO: Might need revisiting to handle for non-shared clauses
+    if (variable) {
+      operands.push_back(variable);
+    } else {
+      if (const auto *details =
+              sym->detailsIf<Fortran::semantics::HostAssocDetails>())
+        operands.push_back(converter.getSymbolAddress(details->symbol()));
+    }
+  };
+
+  for (const auto &pimObject : objectList.v) {
+    std::visit(Fortran::common::visitors{
+                   [&](const Fortran::parser::Designator &designator) {
+                     if (const auto *name =
+                             getDesignatorNameIfDataRef(designator)) {
+                       addOperands(*name->symbol);
+                     }
+                   },
+                   [&](const Fortran::parser::Name &name) {
+                     addOperands(*name.symbol);
+                   }},
+               pimObject.u);
+  }
+}
+
+template <typename Clause>
+static void genObjectListWithModifier(
+    const Clause *x, Fortran::lower::AbstractConverter &converter,
+    Fortran::parser::PimDataModifier::Modifier mod,
+    llvm::SmallVectorImpl<mlir::Value> &operandsWithModifier,
+    llvm::SmallVectorImpl<mlir::Value> &operands) {
+  const Fortran::parser::PimObjectList &listWithModifier = x->v;
+  // const auto &pimObjectList =
+  //     std::get<Fortran::parser::PimObjectList>(listWithModifier.t);
+  // const auto &modifier =
+  //     std::get<std::optional<Fortran::parser::PimDataModifier>>(
+  //         listWithModifier.t);
+  // if (modifier && (*modifier).v == mod) {
+  //   genObjectList(pimObjectList, converter, operandsWithModifier);
+  // } else {
+    genObjectList(listWithModifier, converter, operands);
+  // }
+}
+
+static void
+addOperands(llvm::SmallVectorImpl<mlir::Value> &operands,
+            llvm::SmallVectorImpl<int32_t> &operandSegments,
+            const llvm::SmallVectorImpl<mlir::Value> &clauseOperands) {
+  operands.append(clauseOperands.begin(), clauseOperands.end());
+  operandSegments.push_back(clauseOperands.size());
+}
+
+static mlir::pim::ParallelOp
+createParallelOp(Fortran::lower::AbstractConverter &converter,
+                 Fortran::lower::pft::Evaluation &eval,
+                 Fortran::semantics::SemanticsContext &semanticsContext,
+                 Fortran::lower::StatementContext &stmtCtx,
+                 const Fortran::parser::PimClauseList& pimClauseList) {
+  fir::FirOpBuilder &firOpBuilder = converter.getFirOpBuilder();
+  mlir::Location currentLocation = converter.getCurrentLocation();
+
+  // mlir::Value libcalls;
+
+  llvm::SmallVector<mlir::Value, 2> copyinOperands, copyinReadonlyOperands;
+  llvm::SmallVector<mlir::Value, 2> copyoutOperands, copyoutZeroOperands;
+  for (const Fortran::parser::PimClause &clause : pimClauseList.v) {
+    if (const auto& copyinClause{std::get_if<Fortran::parser::PimClause::Copyin>(&clause.u)}) {
+      genObjectListWithModifier<Fortran::parser::PimClause::Copyin>(
+          copyinClause, converter,
+          Fortran::parser::PimDataModifier::Modifier::ReadOnly,
+          copyinReadonlyOperands, copyinOperands);
+    }
+    if (const auto& copyoutClause{std::get_if<Fortran::parser::PimClause::Copyout>(&clause.u)}) {
+      genObjectListWithModifier<Fortran::parser::PimClause::Copyout>(
+          copyoutClause, converter,
+          Fortran::parser::PimDataModifier::Modifier::Zero, copyoutZeroOperands,
+          copyoutOperands);
+    }
+
+  }
+
+  // llvm::SmallVector<mlir::Value, 2> libcallsOperands;
+  llvm::SmallVector<mlir::Value, 8> operands;
+  llvm::SmallVector<int32_t, 8> operandSegments;
+  addOperands(operands, operandSegments, copyinOperands);
+  // addOperands(operands, operandSegments, copyinReadonlyOperands);
+  addOperands(operands, operandSegments, copyoutOperands);
+  // addOperands(operands, operandSegments, copyoutZeroOperands);
+  // addOperands(operands, operandSegments, libcallsOperands);
+
+
+  llvm::ArrayRef<mlir::Type> argTy;
+  auto parallelOp = firOpBuilder.create<mlir::pim::ParallelOp>(
+      currentLocation, argTy, operands);
+
+  createBodyOfOp<mlir::pim::ParallelOp>(parallelOp, converter, currentLocation,
+                                        eval, operandSegments, &pimClauseList,
+                                        {}, false);
+
+  return parallelOp;
+
+  // auto parallelOp = createRegionOp<mlir::pim::ParallelOp, mlir::pim::YieldOp>(
+  //     firOpBuilder, currentLocation, operands, operandSegments);
+  // return parallelOp;
+}
+
+// static mlir::pim::PimDesc
+// createPimDesc(Fortran::lower::AbstractConverter &converter,
+//               const Fortran::parser::PimClauseList &pimClauseList) {
+//   fir::FirOpBuilder &builder = converter.getFirOpBuilder();
+//   mlir::Location loc = converter.getCurrentLocation();
+
+  // mlir::Value shape = builder.createShape(loc, exv);
+
+  // mlir::pim::PimDesc pimDesc =
+  //     builder.create<mlir::pim::PimDesc>(loc, shape, mlir::pim::FP16_FLAG);
+  // return pimDesc;
+// }
+
+void Fortran::lower::genPimConstruct(
+    Fortran::lower::AbstractConverter &converter,
+    Fortran::semantics::SemanticsContext &semanticsContext,
+    Fortran::lower::pft::Evaluation &eval,
+    const Fortran::parser::PimConstruct &pimConstruct) {
+  std::visit(
+      Fortran::common::visitors{
+          [&](const Fortran::parser::PimBlockConstruct &blockConstruct) {
+            TODO(converter.getCurrentLocation(),
+                 "PIM Block construct not lowered yet!");
+            // genPIM(converter, eval, blockConstruct);
+          },
+          [&](const Fortran::parser::PimCombinedConstruct &combinedConstruct) {
+            const auto &beginBlockDirective =
+                std::get<Fortran::parser::PimBeginCombinedDirective>(
+                    combinedConstruct.t);
+            const auto &pimClauseList =
+                std::get<Fortran::parser::PimClauseList>(beginBlockDirective.t);
+            Fortran::lower::StatementContext stmtCtx;
+            createParallelOp(converter, eval, semanticsContext, stmtCtx, pimClauseList);
+          },
+          [&](const Fortran::parser::PimLoopConstruct &loopConstruct) {
+            TODO(converter.getCurrentLocation(),
+                 "PIM Loop construct not lowered yet!");
+            // genPIM(converter, eval, loopConstruct);
+          },
+      },
+      pimConstruct.u);
+}
+
+
+#include "flang/Lower/DumpEvaluateExpr.h"
+
+
+void Fortran::lower::genPimOperations(
+    Fortran::lower::AbstractConverter &converter,
+    Fortran::lower::pft::Evaluation &eval,
+    const Fortran::parser::PimOperation &pimOp) {
+
+  mlir::Location loc = converter.getCurrentLocation();
+  std::visit(
+      Fortran::common::visitors{
+          [&](const Fortran::parser::PimAdd &pimAdd) {
+              const Fortran::parser::Expr &expr{std::get<Fortran::parser::Expr>(pimAdd.t)};
+              const Fortran::parser::Variable &var{std::get<Fortran::parser::Variable>(pimAdd.t)};
+
+
+              auto *addExpr{Fortran::parser::Unwrap<Fortran::parser::Expr::Add>(expr.u)};
+
+              const Fortran::common::Indirection<Fortran::parser::Expr>& lhs = std::get<0>(addExpr->t);
+              const Fortran::common::Indirection<Fortran::parser::Expr>& rhs = std::get<1>(addExpr->t);
+              // const auto& hhs = std::get<0>(addExpr->t);
+              // const auto& rhs = std::get<0>(addExpr->t);
+
+              mlir::Value lhs_val, rhs_val, var_val;
+
+              std::visit(
+                  Fortran::common::visitors{
+                      [&](const Fortran::common::Indirection<
+                          Fortran::parser::Designator> &designator) {
+                        // assert(*designator &&
+                        //        "Variable designator PIM assert");
+                          const auto *dataRef = std::get_if<Fortran::parser::DataRef>(&designator.value().u);
+                          const Fortran::common::Indirection<
+                                  Fortran::parser::ArrayElement> *arrayElem =
+                              std::get_if<Fortran::common::Indirection<
+                                  Fortran::parser::ArrayElement>>(&dataRef->u);
+                          if (!arrayElem) {
+                            fir::emitFatalError(
+                                loc, "Unexpected non-array element in pim loop");
+                          }
+                          const Fortran::parser::DataRef &baseRef = arrayElem->value().base;
+//   return dataRef ? std::get_if<Fortran::parser::Name>(&dataRef->u) : nullptr;
+                        // const auto *name =
+                        //     getDesignatorNameIfDataRef(designator.value());
+                        const auto *name = std::get_if<Fortran::parser::Name>(&baseRef.u);
+                          const auto variable =
+                              converter.getSymbolAddress(*name->symbol);
+                          lhs_val = variable;
+                      },
+                      [&](auto &&) { assert(false); }},
+                  lhs.value().u);
+
+              std::visit(
+                  Fortran::common::visitors{
+                      [&](const Fortran::common::Indirection<
+                          Fortran::parser::Designator> &designator) {
+                        // assert(*designator &&
+                        //        "Variable designator PIM assert");
+                          const auto *dataRef = std::get_if<Fortran::parser::DataRef>(&designator.value().u);
+                          const Fortran::common::Indirection<
+                                  Fortran::parser::ArrayElement> *arrayElem =
+                              std::get_if<Fortran::common::Indirection<
+                                  Fortran::parser::ArrayElement>>(&dataRef->u);
+                          if (!arrayElem) {
+                            fir::emitFatalError(
+                                loc, "Unexpected non-array element in pim loop");
+                          }
+                          const Fortran::parser::DataRef &baseRef = arrayElem->value().base;
+//   return dataRef ? std::get_if<Fortran::parser::Name>(&dataRef->u) : nullptr;
+                        // const auto *name =
+                        //     getDesignatorNameIfDataRef(designator.value());
+                        const auto *name = std::get_if<Fortran::parser::Name>(&baseRef.u);
+                          const auto variable =
+                              converter.getSymbolAddress(*name->symbol);
+                          rhs_val = variable;
+                      },
+                      [&](auto &&) { assert(false); }},
+                  rhs.value().u);
+
+
+              // Resutl
+              std::visit(
+                  Fortran::common::visitors{
+                      [&](const Fortran::common::Indirection<
+                          Fortran::parser::Designator> &designator) {
+                        // assert(*designator &&
+                        //        "Variable designator PIM assert");
+                          const auto *dataRef = std::get_if<Fortran::parser::DataRef>(&designator.value().u);
+                          const Fortran::common::Indirection<
+                                  Fortran::parser::ArrayElement> *arrayElem =
+                              std::get_if<Fortran::common::Indirection<
+                                  Fortran::parser::ArrayElement>>(&dataRef->u);
+                          if (!arrayElem) {
+                            fir::emitFatalError(
+                                loc, "Unexpected non-array element in pim loop");
+                          }
+                          const Fortran::parser::DataRef &baseRef = arrayElem->value().base;
+//   return dataRef ? std::get_if<Fortran::parser::Name>(&dataRef->u) : nullptr;
+                        // const auto *name =
+                        //     getDesignatorNameIfDataRef(designator.value());
+                        const auto *name = std::get_if<Fortran::parser::Name>(&baseRef.u);
+                          const auto variable =
+                              converter.getSymbolAddress(*name->symbol);
+                          var_val = variable;
+                      },
+                      [&](auto &&) { assert(false); }},
+                  var.u);
+
+              fir::FirOpBuilder &firOpBuilder = converter.getFirOpBuilder();
+
+
+              Fortran::lower::StatementContext stmtCtx;
+              mlir::Value retAddress = fir::getBase(converter.genExprAddr(
+                                                     *Fortran::semantics::GetExpr(var), stmtCtx));
+
+              assert(rhs_val.getType() == lhs_val.getType());
+              mlir::Type operandTy = rhs_val.getType();
+
+              // fir.ref<fir.ref> and fir.ptr<fir.ref> are forbidden. Use
+              // fir.llvm_ptr if needed.
+              auto ty = operandTy.isa<fir::ReferenceType>()
+                            ? mlir::Type(fir::LLVMPointerType::get(operandTy))
+                            : mlir::Type(firOpBuilder.getRefType(operandTy));
+              // return builder.create<fir::CoordinateOp>(loc, ty, tupleArg,
+              //                                          offset);
+
+
+              // mlir::Value temp = firOpBuilder.createTemporary(loc, operandTy,
+              //                                                 llvm::ArrayRef<mlir::NamedAttribute>{
+              //                                                   Fortran::lower::getAdaptToByRefAttr(firOpBuilder)});
+              // mlir::Value temp =
+              //     firOpBuilder.create<mlir::pim::CreateBufferObject>(
+              //         loc, operandTy, var_val);
+
+              auto *context = &converter.getMLIRContext();
+              mlir::Type pimBufferTy = mlir::pim::BufferType::get(context, mlir::FloatType::getF16(context));
+              mlir::Value lhs_buf =
+                  firOpBuilder.create<mlir::pim::CreateBufferObject>(
+                      loc, pimBufferTy, lhs_val, mlir::pim::MemType::HOST);
+              mlir::Value rhs_buf =
+                  firOpBuilder.create<mlir::pim::CreateBufferObject>(
+                      loc, pimBufferTy, rhs_val, mlir::pim::MemType::HOST);
+              mlir::Value ret_buf =
+                  firOpBuilder.create<mlir::pim::CreateBufferObject>(
+                      loc, pimBufferTy, var_val, mlir::pim::MemType::PIM);
+
+
+
+              // ret_buf = firOpBuilder.create<mlir::pim::AddOpNew>(loc, pimBufferTy, lhs_buf, rhs_buf);
+              firOpBuilder.create<mlir::pim::AddOpNew>(loc, lhs_buf, rhs_buf, ret_buf);
+
+              // mlir::Value unwrappedBuf =
+                  firOpBuilder.create<mlir::pim::UnwrapBufferObject>(
+                      loc, ret_buf, var_val);
+
+              // auto resultRef = firOpBuilder.createConvert(loc, var_val.getType(), unwrappedBuf);
+              // firOpBuilder.create<fir::LoadOp>(loc, resultRef);
+              // firOpBuilder.create<fir::StoreOp>(loc, unwrappedBuf, var_val);
+
+          },
+          [&](auto &&) {
+            TODO(converter.getCurrentLocation(),
+                 "PIM op not lowered yet!");
+          },
+      },
+      pimOp.u);
+}
+
+void Fortran::lower::genPimOperations(
+    Fortran::lower::AbstractConverter &converter,
+    Fortran::lower::pft::Evaluation &eval,
+    const Fortran::parser::PimConstruct &pimConstruct) {
+
+    // const auto &doLoop = std::get<Fortran::parser::PimLoopConstruct>(pimConstruct.u);
+    // const auto &doConstruct = std::get<std::optional<Fortran::parser::DoConstruct>>(doLoop.t);
+    // const auto &block = std::get<Fortran::parser::Block>(doConstruct->t);
+
+    // for (const auto & x : block) {
+    // std::visit(Fortran::common::visitors{
+    //                [&](const Fortran::parser::Designator &designator) {
+    //   const auto &smth = std::get<Fortran::parser::
+    //   LLVM_DEBUG(Fortran::lower::DumpEvaluateExpr::dump(
+    //       llvm::dbgs() << "determine shape of:\n", x.));
+    // }
+
+    // const auto &doConstruct = std::get<Fortran::parser::DoConstruct>(doLoop.t);
+    // doCon
+
+  // llvm::SmallVector<mlir::Value> lowerBound, upperBound, step, linearVars,
+  //     linearStepVars, reductionVars;
+  // // Collect the loops to collapse.
+  // auto *doConstructEval = &eval.getFirstNestedEvaluation();
+
+  // const auto &loopOpClauseList = std::get<Fortran::parser::OmpClauseList>(
+  //     std::get<Fortran::parser::OmpBeginLoopDirective>(loopConstruct.t).t);
+
+  // std::int64_t collapseValue =
+  //     Fortran::lower::getCollapseValue(loopOpClauseList);
+  // std::size_t loopVarTypeSize = 0;
+  // SmallVector<const Fortran::semantics::Symbol *> iv;
+  // do {
+  //   auto *doLoop = &doConstructEval->getFirstNestedEvaluation();
+  //   auto *doStmt = doLoop->getIf<Fortran::parser::NonLabelDoStmt>();
+  //   assert(doStmt && "Expected do loop to be in the nested evaluation");
+  //   const auto &loopControl =
+  //       std::get<std::optional<Fortran::parser::LoopControl>>(doStmt->t);
+  //   const Fortran::parser::LoopControl::Bounds *bounds =
+  //       std::get_if<Fortran::parser::LoopControl::Bounds>(&loopControl->u);
+  //   assert(bounds && "Expected bounds for worksharing do loop");
+  //   Fortran::lower::StatementContext stmtCtx;
+  //   lowerBound.push_back(fir::getBase(converter.genExprValue(
+  //       *Fortran::semantics::GetExpr(bounds->lower), stmtCtx)));
+  //   upperBound.push_back(fir::getBase(converter.genExprValue(
+  //       *Fortran::semantics::GetExpr(bounds->upper), stmtCtx)));
+  //   if (bounds->step) {
+  //     step.push_back(fir::getBase(converter.genExprValue(
+  //         *Fortran::semantics::GetExpr(bounds->step), stmtCtx)));
+  //   } else { // If `step` is not present, assume it as `1`.
+  //     step.push_back(firOpBuilder.createIntegerConstant(
+  //         currentLocation, firOpBuilder.getIntegerType(32), 1));
+  //   }
+  //   iv.push_back(bounds->name.thing.symbol);
+  //   loopVarTypeSize = std::max(loopVarTypeSize,
+  //                              bounds->name.thing.symbol->GetUltimate().size());
+
+  //   collapseValue--;
+  //   doConstructEval =
+  //       &*std::next(doConstructEval->getNestedEvaluations().begin());
+  // } while (collapseValue > 0);
+  
+
+  fir::FirOpBuilder &builder = converter.getFirOpBuilder();
+
+
+  // ---------------------------------------------------------------------------
+
+  // // Collect the loops to collapse.
+  // auto *doConstructEval = &eval.getFirstNestedEvaluation();
+
+  // // std::int64_t collapseValue =
+  // //     Fortran::lower::getCollapseValue(loopOpClauseList);
+  // std::size_t loopVarTypeSize = 0;
+  // SmallVector<const Fortran::semantics::Symbol *> iv;
+  // do {
+  //   auto *doLoop = &doConstructEval->getFirstNestedEvaluation();
+  //   auto *doStmt = doLoop->getIf<Fortran::parser::NonLabelDoStmt>();
+  //   assert(doStmt && "Expected do loop to be in the nested evaluation");
+  //   const auto &loopControl =
+  //       std::get<std::optional<Fortran::parser::LoopControl>>(doStmt->t);
+  //   const Fortran::parser::LoopControl::Bounds *bounds =
+  //       std::get_if<Fortran::parser::LoopControl::Bounds>(&loopControl->u);
+  //   assert(bounds && "Expected bounds for worksharing do loop");
+  //   Fortran::lower::StatementContext stmtCtx;
+  //   lowerBound.push_back(fir::getBase(converter.genExprValue(
+  //       *Fortran::semantics::GetExpr(bounds->lower), stmtCtx)));
+  //   upperBound.push_back(fir::getBase(converter.genExprValue(
+  //       *Fortran::semantics::GetExpr(bounds->upper), stmtCtx)));
+  //   if (bounds->step) {
+  //     step.push_back(fir::getBase(converter.genExprValue(
+  //         *Fortran::semantics::GetExpr(bounds->step), stmtCtx)));
+  //   } else { // If `step` is not present, assume it as `1`.
+  //     step.push_back(firOpBuilder.createIntegerConstant(
+  //         currentLocation, firOpBuilder.getIntegerType(32), 1));
+  //   }
+  //   iv.push_back(bounds->name.thing.symbol);
+  //   loopVarTypeSize = std::max(loopVarTypeSize,
+  //                              bounds->name.thing.symbol->GetUltimate().size());
+
+  //   // collapseValue--;
+  //   doConstructEval =
+  //       &*std::next(doConstructEval->getNestedEvaluations().begin());
+  // } while (doConstructEval != doConstructEval->getNestedEvaluations().end());
+
+  // ---------------------------------------------------------------------------
+
+
+
+  LLVM_DEBUG(llvm::dbgs() << "PIM eval begin >>>\n");
+  for (Fortran::lower::pft::Evaluation &e : eval.getNestedEvaluations()) {
+    e.dump();
+    LLVM_DEBUG(llvm::dbgs() << "e.isActionStmt(): " << e.isActionStmt() << "\n");
+    // LLVM_DEBUG(assign.lhs.AsFortran(llvm::dbgs() << "PIM candidate: ") << '\n';
+    //            assign.rhs.AsFortran(llvm::dbgs() << "assign expression: "));
+    if (auto *endDo = e.getIf<Fortran::parser::EndDoStmt>()) {
+      LLVM_DEBUG(llvm::dbgs() << "PIM END DO detected: \n");
+    } else if (auto *endDo = e.getIf<Fortran::parser::NonLabelDoStmt>()) {
+      LLVM_DEBUG(llvm::dbgs() << "PIM NonLabelDoStmt detected: \n");
+    } else if (auto *assignmentStmt = e.getIf<Fortran::parser::AssignmentStmt>()) {
+      const Fortran::evaluate::Assignment &assign = *assignmentStmt->typedAssignment->v;
+
+      LLVM_DEBUG(assign.lhs.AsFortran(llvm::dbgs() << "PIM candidate array: ") << '\n';
+                 assign.rhs.AsFortran(llvm::dbgs() << "assign expression: "));
+      // Proceed in the same way as in genAssgnment
+      std::optional<Fortran::evaluate::DynamicType> lhsType =
+          assign.lhs.GetType();
+      assert(lhsType && "Assign to typeless LHS");
+      if (lhsType->category() != Fortran::common::TypeCategory::Real ||
+          lhsType->category() != Fortran::common::TypeCategory::Integer) {
+        TODO(converter.getCurrentLocation(),
+             "Supported types for pim lowering: Real, Integer");
+      }
+      if (lhsType->IsPolymorphic()) {
+        TODO(converter.getCurrentLocation(),
+             "Unsupported polymorphic type types for pim");
+      }
+      // TODO: fp16 assert
+      // TODO: Check explicitIterationSpace()
+      // if (assign.lhs.Rank() > 0 || explicitIterationSpace()) {
+      if (assign.lhs.Rank() > 0) {
+        // LLVM_DEBUG(assign.lhs.AsFortran(llvm::dbgs() << "pim array: ") << '\n';
+        //            assign.rhs.AsFortran(llvm::dbgs() << "assign expression: "));
+        // Array assignment
+        // genArrayAssignment(assign, stmtCtx);
+        // mlir::Location loc = converter.getCurrentLocation();
+        // mlir::Type arrTy = fir::dyn_cast_ptrOrBoxEleTy(lhsType);
+
+
+        // builder.create<mlir::pim::SumOp>(loc, assign.lhs, assign.rhs);
+        return;
+      } else {
+        TODO(converter.getCurrentLocation(), "Scalar pim assignment");
+      }
+    }
+  }
+  LLVM_DEBUG(llvm::dbgs() << "PIM eval end <<<\n" << '\n');
+}
diff --git a/flang/lib/Optimizer/CodeGen/CMakeLists.txt b/flang/lib/Optimizer/CodeGen/CMakeLists.txt
index e4bc0d8bb680..10819ce15203 100644
--- a/flang/lib/Optimizer/CodeGen/CMakeLists.txt
+++ b/flang/lib/Optimizer/CodeGen/CMakeLists.txt
@@ -20,6 +20,7 @@ add_flang_library(FIRCodeGen
   MLIRMathToLLVM
   MLIRMathToLibm
   MLIROpenMPToLLVM
+  MLIRPimToLLVM
   MLIRLLVMToLLVMIRTranslation
   MLIRTargetLLVMIRExport
 
diff --git a/flang/lib/Optimizer/CodeGen/CodeGen.cpp b/flang/lib/Optimizer/CodeGen/CodeGen.cpp
index 335ce24d221d..a6d07cbd9868 100644
--- a/flang/lib/Optimizer/CodeGen/CodeGen.cpp
+++ b/flang/lib/Optimizer/CodeGen/CodeGen.cpp
@@ -26,12 +26,15 @@
 #include "mlir/Conversion/MathToLLVM/MathToLLVM.h"
 #include "mlir/Conversion/MathToLibm/MathToLibm.h"
 #include "mlir/Conversion/OpenMPToLLVM/ConvertOpenMPToLLVM.h"
+#include "mlir/Conversion/PimToLLVM/ConvertPimToLLVM.h"
 #include "mlir/IR/BuiltinTypes.h"
 #include "mlir/IR/Matchers.h"
 #include "mlir/Pass/Pass.h"
 #include "mlir/Target/LLVMIR/ModuleTranslation.h"
 #include "llvm/ADT/ArrayRef.h"
 
+// #include "mlir/Dialect/Pim/Pim.h"
+
 #define DEBUG_TYPE "flang-codegen"
 
 // fir::LLVMTypeConverter for converting to LLVM IR dialect types.
@@ -3315,8 +3318,7 @@ public:
         SliceOpConversion, StoreOpConversion, StringLitOpConversion,
         SubcOpConversion, UnboxCharOpConversion, UnboxProcOpConversion,
         UndefOpConversion, UnreachableOpConversion, XArrayCoorOpConversion,
-        XEmboxOpConversion, XReboxOpConversion, ZeroOpConversion>(typeConverter,
-                                                                  options);
+        XEmboxOpConversion, XReboxOpConversion, ZeroOpConversion>(typeConverter, options);
     mlir::populateFuncToLLVMConversionPatterns(typeConverter, pattern);
     mlir::populateOpenMPToLLVMConversionPatterns(typeConverter, pattern);
     mlir::arith::populateArithmeticToLLVMConversionPatterns(typeConverter,
@@ -3336,6 +3338,10 @@ public:
     mlir::configureOpenMPToLLVMConversionLegality(target, typeConverter);
     target.addLegalDialect<mlir::omp::OpenMPDialect>();
 
+
+    mlir::populatePimToLLVMConversionPatterns(typeConverter, pattern);
+    target.addLegalDialect<mlir::pim::PimDialect>();
+
     // required NOPs for applying a full conversion
     target.addLegalOp<mlir::ModuleOp>();
 
diff --git a/flang/lib/Optimizer/CodeGen/PassDetail.h b/flang/lib/Optimizer/CodeGen/PassDetail.h
index f7030131beff..9de9c33d3c7a 100644
--- a/flang/lib/Optimizer/CodeGen/PassDetail.h
+++ b/flang/lib/Optimizer/CodeGen/PassDetail.h
@@ -12,6 +12,7 @@
 #include "flang/Optimizer/Dialect/FIRDialect.h"
 #include "mlir/Dialect/LLVMIR/LLVMDialect.h"
 #include "mlir/Dialect/OpenMP/OpenMPDialect.h"
+#include "mlir/Dialect/Pim/PimDialect.h"
 #include "mlir/IR/BuiltinDialect.h"
 #include "mlir/Pass/Pass.h"
 #include "mlir/Pass/PassRegistry.h"
diff --git a/flang/lib/Optimizer/Dialect/CMakeLists.txt b/flang/lib/Optimizer/Dialect/CMakeLists.txt
index c991b43239d4..f36b1f2b71fd 100644
--- a/flang/lib/Optimizer/Dialect/CMakeLists.txt
+++ b/flang/lib/Optimizer/Dialect/CMakeLists.txt
@@ -14,6 +14,7 @@ add_flang_library(FIRDialect
   FIRSupport
   MLIRArithmeticDialect
   MLIROpenMPToLLVM
+  MLIRPimToLLVM
   MLIRLLVMToLLVMIRTranslation
   MLIRTargetLLVMIRExport
 
diff --git a/flang/lib/Optimizer/Support/CMakeLists.txt b/flang/lib/Optimizer/Support/CMakeLists.txt
index 779e20711513..bccb88b5251f 100644
--- a/flang/lib/Optimizer/Support/CMakeLists.txt
+++ b/flang/lib/Optimizer/Support/CMakeLists.txt
@@ -14,6 +14,7 @@ add_flang_library(FIRSupport
   LINK_LIBS
   ${dialect_libs}
   MLIROpenMPToLLVMIRTranslation
+  MLIRPimToLLVMIRTranslation
   MLIRLLVMToLLVMIRTranslation
   MLIRTargetLLVMIRExport
 )
diff --git a/flang/lib/Optimizer/Transforms/CMakeLists.txt b/flang/lib/Optimizer/Transforms/CMakeLists.txt
index 60891438ad5a..c94908411b08 100644
--- a/flang/lib/Optimizer/Transforms/CMakeLists.txt
+++ b/flang/lib/Optimizer/Transforms/CMakeLists.txt
@@ -12,6 +12,7 @@ add_flang_library(FIRTransforms
   SimplifyRegionLite.cpp
   AlgebraicSimplification.cpp
   SimplifyIntrinsics.cpp
+  PimDataOperandConversion.cpp
 
   DEPENDS
   FIRBuilder
@@ -29,4 +30,6 @@ add_flang_library(FIRTransforms
   MLIROpenACCDialect
   MLIROpenMPDialect
   FIRSupport
+  FIRCodeGen
+  MLIRPimToLLVMIRTranslation
 )
diff --git a/flang/lib/Optimizer/Transforms/PimDataOperandConversion.cpp b/flang/lib/Optimizer/Transforms/PimDataOperandConversion.cpp
new file mode 100644
index 000000000000..b239c461e899
--- /dev/null
+++ b/flang/lib/Optimizer/Transforms/PimDataOperandConversion.cpp
@@ -0,0 +1,125 @@
+//===- PimDataOperandConversion.cpp -- convert Pim data operand -*---------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "PassDetail.h"
+#include "flang/Optimizer/Dialect/FIROps.h"
+#include "flang/Optimizer/Dialect/FIRType.h"
+#include "flang/Optimizer/Transforms/Passes.h"
+#include "mlir/Conversion/PimToLLVM/ConvertPimToLLVM.h"
+// #include "mlir/Conversion/StandardToLLVM/ConvertStandardToLLVM.h"
+#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
+#include "mlir/Dialect/Pim/Pim.h"
+#include "mlir/Pass/Pass.h"
+#include "mlir/Transforms/DialectConversion.h"
+
+#include "mlir/Dialect/Pim/Pim.h"
+#include "mlir/Dialect/MemRef/IR/MemRef.h"
+#include "mlir/Pass/Pass.h"
+#include <mlir/IR/PatternMatch.h>
+#include <mlir/Support/LogicalResult.h>
+
+#define DEBUG_TYPE "flang-pim-conversion"
+#include "../CodeGen/TypeConverter.h"
+
+using namespace mlir;
+
+//===----------------------------------------------------------------------===//
+// Conversion patterns
+//===----------------------------------------------------------------------===//
+
+namespace {
+
+class PimArgConversion : public mlir::OpRewritePattern<mlir::pim::AddOpNew> {
+public:
+  using OpRewritePattern::OpRewritePattern;
+  mlir::LogicalResult
+  matchAndRewrite(mlir::pim::AddOpNew op,
+                  mlir::PatternRewriter &rewriter) const override {
+    LLVM_DEBUG(llvm::dbgs() << "PimArgConversion: running on :\n";
+               op.print(llvm::dbgs()););
+    // rewriter.replaceOpWithNewOp<fir::AllocaOp>(op, convertMemRef(op.getType()),
+    //                                            op.memref());
+    return success();
+  }
+};
+
+
+// class MangleNameOnCallOp : public mlir::OpRewritePattern<fir::CallOp> {
+// public:
+//   using OpRewritePattern::OpRewritePattern;
+
+//   mlir::LogicalResult
+//   matchAndRewrite(fir::CallOp op,
+//                   mlir::PatternRewriter &rewriter) const override {
+//     rewriter.startRootUpdate(op);
+//     auto callee = op.getCallee();
+//     if (callee) {
+//       auto result =
+//           fir::NameUniquer::deconstruct(callee->getRootReference().getValue());
+//       if (fir::NameUniquer::isExternalFacingUniquedName(result))
+//         op.setCalleeAttr(
+//             SymbolRefAttr::get(op.getContext(), mangleExternalName(result)));
+//     }
+//     rewriter.finalizeRootUpdate(op);
+//     return success();
+//   }
+// };
+
+
+} // namespace
+
+namespace {
+
+// <mlir::pim::AddOpNew>
+// template <typename PimOp>
+class PimArgConvertionToLLVMTypes : public mlir::OpRewritePattern<pim::CreateBufferObject> {
+public:
+  using OpRewritePattern::OpRewritePattern;
+  mlir::LogicalResult
+  matchAndRewrite(pim::CreateBufferObject op,
+                  mlir::PatternRewriter &rewriter) const override {
+    LLVM_DEBUG(llvm::dbgs() << "PimArgConvertionToLLVMTypes: running on :\n";
+               op.print(llvm::dbgs()););
+    return success();
+  }
+
+};
+
+
+
+class ConvertPimToLLVMPass
+    : public fir::PimFirDataConversionBase<ConvertPimToLLVMPass> {
+public:
+  // mlir::ModuleOp getModule() { return getOperation(); }
+  void runOnOperation() override {
+    auto *context = &getContext();
+    auto function = getOperation();
+    LLVM_DEBUG(llvm::dbgs() << "ConvertPimToLLVMPass: running on function:\n";
+               function.print(llvm::dbgs()););
+    mlir::RewritePatternSet patterns(context);
+    patterns.insert<PimArgConvertionToLLVMTypes>(context);
+
+    mlir::ConversionTarget target(*context);
+    target.addLegalDialect<mlir::pim::PimDialect, fir::FIROpsDialect,
+                           mlir::arith::ArithmeticDialect,
+                           mlir::func::FuncDialect>();
+    if (mlir::failed(mlir::applyPartialConversion(function, target,
+                                                  std::move(patterns)))) {
+      mlir::emitError(mlir::UnknownLoc::get(context),
+                      "error in converting pim dialect\n");
+      signalPassFailure();
+    }
+  }
+};
+} // namespace
+
+
+
+std::unique_ptr<mlir::Pass> fir::createPimDataOperandConversionPass() {
+  return std::make_unique<ConvertPimToLLVMPass>();
+}
diff --git a/flang/lib/Parser/CMakeLists.txt b/flang/lib/Parser/CMakeLists.txt
index 600a2f67df44..b37175fd5e70 100644
--- a/flang/lib/Parser/CMakeLists.txt
+++ b/flang/lib/Parser/CMakeLists.txt
@@ -11,6 +11,7 @@ add_flang_library(FortranParser
   io-parsers.cpp
   message.cpp
   openacc-parsers.cpp
+  pim-parsers.cpp
   openmp-parsers.cpp
   parse-tree.cpp
   parsing.cpp
@@ -30,8 +31,10 @@ add_flang_library(FortranParser
   LINK_COMPONENTS
   Support
   FrontendOpenACC
+  FrontendPIM
 
   DEPENDS
   omp_gen
   acc_gen
+  pim_gen
 )
diff --git a/flang/lib/Parser/executable-parsers.cpp b/flang/lib/Parser/executable-parsers.cpp
index 04fe1849a6fd..3002c323f2d2 100644
--- a/flang/lib/Parser/executable-parsers.cpp
+++ b/flang/lib/Parser/executable-parsers.cpp
@@ -53,6 +53,8 @@ constexpr auto executableConstruct{
         construct<ExecutableConstruct>(indirect(openmpConstruct)),
         construct<ExecutableConstruct>(indirect(accEndCombinedDirective)),
         construct<ExecutableConstruct>(indirect(openaccConstruct)),
+        construct<ExecutableConstruct>(indirect(pimEndCombinedDirective)),
+        construct<ExecutableConstruct>(indirect(pimConstruct)),
         construct<ExecutableConstruct>(indirect(compilerDirective)))};
 
 // R510 execution-part-construct ->
diff --git a/flang/lib/Parser/parsing.cpp b/flang/lib/Parser/parsing.cpp
index 1af8afef18ca..1109e119a301 100644
--- a/flang/lib/Parser/parsing.cpp
+++ b/flang/lib/Parser/parsing.cpp
@@ -80,6 +80,10 @@ const SourceFile *Parsing::Prescan(const std::string &path, Options options) {
   if (options.features.IsEnabled(LanguageFeature::OpenACC)) {
     prescanner.AddCompilerDirectiveSentinel("$acc");
   }
+  if (options.features.IsEnabled(LanguageFeature::Pim)) {
+    prescanner.AddCompilerDirectiveSentinel("$pim");
+    prescanner.AddCompilerDirectiveSentinel("$");
+  }
   if (options.features.IsEnabled(LanguageFeature::OpenMP)) {
     prescanner.AddCompilerDirectiveSentinel("$omp");
     prescanner.AddCompilerDirectiveSentinel("$"); // OMP conditional line
diff --git a/flang/lib/Parser/pim-parsers.cpp b/flang/lib/Parser/pim-parsers.cpp
new file mode 100644
index 000000000000..b2acff048c2a
--- /dev/null
+++ b/flang/lib/Parser/pim-parsers.cpp
@@ -0,0 +1,224 @@
+//===-- lib/Parser/pim-parsers.cpp ----------------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+// Top-level grammar specification for Pim
+
+#include "basic-parsers.h"
+#include "expr-parsers.h"
+#include "misc-parsers.h"
+#include "stmt-parser.h"
+#include "token-parsers.h"
+#include "type-parser-implementation.h"
+#include "flang/Parser/parse-tree.h"
+
+// Pim Directives and Clauses
+namespace Fortran::parser {
+
+constexpr auto startPimLine = skipStuffBeforeStatement >> "!$PIM "_sptok;
+constexpr auto endPimLine = space >> endOfLine;
+
+// Basic clauses
+TYPE_PARSER("COPY"_tok >> construct<PimClause>(construct<PimClause::Copy>(
+                              parenthesized(Parser<PimObjectList>{}))) ||
+    "COPYIN"_tok >> construct<PimClause>(construct<PimClause::Copyin>(
+                        parenthesized(Parser<PimObjectList>{}))) ||
+    "COPYOUT"_tok >> construct<PimClause>(construct<PimClause::Copyout>(
+                         parenthesized(Parser<PimObjectList>{}))) ||
+    "DEFAULT" >> construct<PimClause>(
+                     construct<PimClause::Default>(Parser<PimDefaultClause>{})))
+
+TYPE_PARSER(
+    construct<PimObject>(designator) || construct<PimObject>("/" >> name / "/"))
+
+TYPE_PARSER(construct<PimObjectList>(nonemptyList(Parser<PimObject>{})))
+
+TYPE_PARSER(construct<PimObjectListWithModifier>(
+    maybe(Parser<PimDataModifier>{}), Parser<PimObjectList>{}))
+
+// 2.16.3 (2485) wait-argument is:
+//   [devnum : int-expr :] [queues :] int-expr-list
+// TYPE_PARSER(construct<PimWaitArgument>(maybe("DEVNUM:" >> scalarIntExpr / ":"),
+//     "QUEUES:" >> nonemptyList(scalarIntExpr) || nonemptyList(scalarIntExpr)))
+
+// 2.9 (1609) size-expr is one of:
+//   * (represented as an empty std::optional<ScalarIntExpr>)
+//   int-expr
+// TYPE_PARSER(construct<PimSizeExpr>(scalarIntExpr) ||
+//     construct<PimSizeExpr>("*" >> construct<std::optional<ScalarIntExpr>>()))
+// TYPE_PARSER(construct<PimSizeExprList>(nonemptyList(Parser<PimSizeExpr>{})))
+
+// tile size is one of:
+//   * (represented as an empty std::optional<ScalarIntExpr>)
+//   constant-int-expr
+// TYPE_PARSER(construct<PimTileExpr>(scalarIntConstantExpr) ||
+//     construct<PimTileExpr>(
+//         "*" >> construct<std::optional<ScalarIntConstantExpr>>()))
+// TYPE_PARSER(construct<PimTileExprList>(nonemptyList(Parser<PimTileExpr>{})))
+
+// 2.9 (1607) gang-arg is:
+//   [[num:]int-expr][[,]static:size-expr]
+// TYPE_PARSER(construct<PimGangArgument>(
+//     maybe(("NUM:"_tok >> scalarIntExpr || scalarIntExpr)),
+//     maybe(", STATIC:" >> Parser<PimSizeExpr>{})))
+
+// 2.5.13 Reduction
+// Operator for reduction
+// TYPE_PARSER(sourced(construct<PimReductionOperator>(
+//     first("+" >> pure(PimReductionOperator::Operator::Plus),
+//         "*" >> pure(PimReductionOperator::Operator::Multiply),
+//         "MAX" >> pure(PimReductionOperator::Operator::Max),
+//         "MIN" >> pure(PimReductionOperator::Operator::Min),
+//         "IAND" >> pure(PimReductionOperator::Operator::Iand),
+//         "IOR" >> pure(PimReductionOperator::Operator::Ior),
+//         "IEOR" >> pure(PimReductionOperator::Operator::Ieor),
+//         ".AND." >> pure(PimReductionOperator::Operator::And),
+//         ".OR." >> pure(PimReductionOperator::Operator::Or),
+//         ".EQV." >> pure(PimReductionOperator::Operator::Eqv),
+//         ".NEQV." >> pure(PimReductionOperator::Operator::Neqv)))))
+
+// 2.15.1 Bind clause
+// TYPE_PARSER(sourced(construct<PimBindClause>(parenthesized(name))) ||
+//     sourced(construct<PimBindClause>(parenthesized(scalarDefaultCharExpr))))
+
+// 2.5.14 Default clause
+TYPE_PARSER(construct<PimDefaultClause>(parenthesized(
+    first("NONE" >> pure(llvm::pim::DefaultValue::PIM_Default_none),
+        "PRESENT" >> pure(llvm::pim::DefaultValue::PIM_Default_present)))))
+
+// SELF clause is either a simple optional condition for compute construct
+// or a synonym of the HOST clause for the update directive 2.14.4 holding
+// an object list.
+// TYPE_PARSER(construct<PimSelfClause>(parenthesized(Parser<PimObjectList>{})) ||
+//     construct<PimSelfClause>(maybe(parenthesized(scalarLogicalExpr))))
+
+// Modifier for copyin, copyout, cache and create
+TYPE_PARSER(construct<PimDataModifier>(
+    first("ZERO:" >> pure(PimDataModifier::Modifier::Zero),
+        "READONLY:" >> pure(PimDataModifier::Modifier::ReadOnly))))
+
+// Combined directives
+TYPE_PARSER(sourced(construct<PimCombinedDirective>(
+    first("PARALLEL LOOP" >> pure(llvm::pim::Directive::PIMD_parallel_loop)))))
+
+// Block directives
+TYPE_PARSER(sourced(construct<PimBlockDirective>(
+    first("PARALLEL" >> pure(llvm::pim::Directive::PIMD_parallel)))))
+
+// Standalone directives
+// TYPE_PARSER(sourced(construct<PimStandaloneDirective>(
+//     first("ENTER DATA" >> pure(llvm::pim::Directive::PIMD_enter_data),
+//         "EXIT DATA" >> pure(llvm::pim::Directive::PIMD_exit_data),
+//         "INIT" >> pure(llvm::pim::Directive::PIMD_init),
+//         "SHUTDOWN" >> pure(llvm::pim::Directive::PIMD_shutdown),
+//         "SET" >> pure(llvm::pim::Directive::PIMD_set),
+//         "UPDATE" >> pure(llvm::pim::Directive::PIMD_update)))))
+
+// Loop directives
+TYPE_PARSER(sourced(construct<PimLoopDirective>(
+    first("LOOP" >> pure(llvm::pim::Directive::PIMD_loop)))))
+
+TYPE_PARSER(construct<PimBeginLoopDirective>(
+    sourced(Parser<PimLoopDirective>{}), Parser<PimClauseList>{}))
+
+TYPE_PARSER(
+    construct<PimLoopConstruct>(sourced(Parser<PimBeginLoopDirective>{})))
+
+// 2.15.1 Routine directive
+// TYPE_PARSER(sourced(construct<PimRoutineConstruct>(verbatim("ROUTINE"_tok),
+//     maybe(parenthesized(name)), Parser<PimClauseList>{})))
+
+// 2.10 Cache directive
+// TYPE_PARSER(sourced(
+//     construct<PimCacheConstruct>(sourced(construct<Verbatim>("CACHE"_tok)),
+//         parenthesized(Parser<PimObjectListWithModifier>{}))))
+
+// 2.11 Combined constructs
+TYPE_PARSER(construct<PimBeginCombinedDirective>(
+    sourced(Parser<PimCombinedDirective>{}), Parser<PimClauseList>{}))
+
+// 2.12 Atomic constructs
+// TYPE_PARSER(construct<PimEndAtomic>(startPimLine >> "END ATOMIC"_tok))
+
+// TYPE_PARSER("ATOMIC" >>
+//     construct<PimAtomicRead>(verbatim("READ"_tok) / endPimLine,
+//         statement(assignmentStmt), maybe(Parser<PimEndAtomic>{} / endPimLine)))
+
+// TYPE_PARSER("ATOMIC" >>
+//     construct<PimAtomicWrite>(verbatim("WRITE"_tok) / endPimLine,
+//         statement(assignmentStmt), maybe(Parser<PimEndAtomic>{} / endPimLine)))
+
+// TYPE_PARSER("ATOMIC" >>
+//     construct<PimAtomicUpdate>(maybe(verbatim("UPDATE"_tok)) / endPimLine,
+//         statement(assignmentStmt), maybe(Parser<PimEndAtomic>{} / endPimLine)))
+
+// TYPE_PARSER("ATOMIC" >>
+//     construct<PimAtomicCapture>(verbatim("CAPTURE"_tok) / endPimLine,
+//         statement(assignmentStmt), statement(assignmentStmt),
+//         Parser<PimEndAtomic>{} / endPimLine))
+
+// TYPE_PARSER(
+//     sourced(construct<PimAtomicConstruct>(Parser<PimAtomicRead>{})) ||
+//     sourced(construct<PimAtomicConstruct>(Parser<PimAtomicCapture>{})) ||
+//     sourced(construct<PimAtomicConstruct>(Parser<PimAtomicWrite>{})) ||
+//     sourced(construct<PimAtomicConstruct>(Parser<PimAtomicUpdate>{})))
+
+// 2.13 Declare constructs
+// TYPE_PARSER(sourced(construct<PimDeclarativeDirective>(
+//     first("DECLARE" >> pure(llvm::pim::Directive::PIMD_declare)))))
+
+// [Clause, [Clause], ...]
+TYPE_PARSER(sourced(construct<PimClauseList>(
+    many(maybe(","_tok) >> sourced(Parser<PimClause>{})))))
+
+// 2.16.3 Wait directive
+// TYPE_PARSER(sourced(construct<PimWaitConstruct>(
+//     sourced(construct<Verbatim>("WAIT"_tok)),
+//     maybe(parenthesized(Parser<PimWaitArgument>{})), Parser<PimClauseList>{})))
+
+// Block Constructs
+TYPE_PARSER(sourced(construct<PimBeginBlockDirective>(
+    sourced(Parser<PimBlockDirective>{}), Parser<PimClauseList>{})))
+
+
+TYPE_PARSER(construct<PimBlockConstruct>(
+    Parser<PimBeginBlockDirective>{} / endPimLine, block,
+    Parser<PimEndBlockDirective>{} / endPimLine))
+
+TYPE_PARSER(
+    startPimLine >> sourced(construct<PimEndBlockDirective>(
+                        sourced("END"_tok >> Parser<PimBlockDirective>{}),
+                        Parser<PimClauseList>{})))
+
+// Standalone constructs
+// TYPE_PARSER(construct<PimStandaloneConstruct>(
+//     sourced(Parser<PimStandaloneDirective>{}), Parser<PimClauseList>{}))
+
+// Standalone declarative constructs
+// TYPE_PARSER(construct<PimStandaloneDeclarativeConstruct>(
+//     sourced(Parser<PimDeclarativeDirective>{}), Parser<PimClauseList>{}))
+
+// TYPE_PARSER(
+//     startPimLine >> first(sourced(construct<PimDeclarativeConstruct>(
+//                               Parser<PimStandaloneDeclarativeConstruct>{})),
+//                         sourced(construct<PimDeclarativeConstruct>(
+//                             Parser<PimRoutineConstruct>{}))))
+
+// Pim constructs
+TYPE_CONTEXT_PARSER("Pim construct"_en_US,
+    startPimLine >>
+        first(construct<PimConstruct>(Parser<PimBlockConstruct>{}),
+            construct<PimConstruct>(Parser<PimCombinedConstruct>{}),
+            construct<PimConstruct>(Parser<PimLoopConstruct>{})))
+
+TYPE_PARSER(startPimLine >> sourced(construct<PimEndCombinedDirective>(sourced(
+                                "END"_tok >> Parser<PimCombinedDirective>{}))))
+
+TYPE_PARSER(construct<PimCombinedConstruct>(
+    sourced(Parser<PimBeginCombinedDirective>{} / endPimLine)))
+
+} // namespace Fortran::parser
diff --git a/flang/lib/Parser/type-parsers.h b/flang/lib/Parser/type-parsers.h
index b5f6e34d3a72..6a3ada02d4af 100644
--- a/flang/lib/Parser/type-parsers.h
+++ b/flang/lib/Parser/type-parsers.h
@@ -137,5 +137,8 @@ constexpr Parser<OpenACCDeclarativeConstruct> openaccDeclarativeConstruct;
 constexpr Parser<OpenMPConstruct> openmpConstruct;
 constexpr Parser<OpenMPDeclarativeConstruct> openmpDeclarativeConstruct;
 constexpr Parser<OmpEndLoopDirective> ompEndLoopDirective;
+
+constexpr Parser<PimConstruct> pimConstruct;
+constexpr Parser<PimEndCombinedDirective> pimEndCombinedDirective;
 } // namespace Fortran::parser
 #endif // FORTRAN_PARSER_TYPE_PARSERS_H_
diff --git a/flang/lib/Parser/unparse.cpp b/flang/lib/Parser/unparse.cpp
index f5381dd39b9a..921bcb0f2675 100644
--- a/flang/lib/Parser/unparse.cpp
+++ b/flang/lib/Parser/unparse.cpp
@@ -17,6 +17,7 @@
 #include "flang/Parser/parse-tree-visitor.h"
 #include "flang/Parser/parse-tree.h"
 #include "flang/Parser/tools.h"
+#include "llvm/Frontend/Pim/PIM.h.inc"
 #include "llvm/Support/raw_ostream.h"
 #include <algorithm>
 #include <cinttypes>
@@ -1975,6 +1976,97 @@ public:
     Walk("DEVNUM:", std::get<std::optional<ScalarIntExpr>>(x.t), ":");
     Walk(std::get<std::list<ScalarIntExpr>>(x.t), ",");
   }
+  // struct PimClause;
+  // struct PimBlockDirective;
+  // struct PimClauseList;
+  // struct PimLoopDirective;
+  // struct PimBeginLoopDirective;
+  // struct PimBeginBlockDirective;
+  // struct PimEndBlockDirective;
+  // struct PimLoopConstruct;
+  // struct PimRoutineConstruct;
+  // struct PimBlockConstruct;
+  // struct PimConstruct;
+  // struct PimDefaultClause;
+  // struct PimCombinedDirective;
+  // struct PimBeginCombinedDirective;
+  // struct PimEndCombinedDirective;
+  // struct PimCombinedConstruct;
+#define GEN_FLANG_CLAUSE_UNPARSE
+#include "llvm/Frontend/Pim/PIM.inc"
+  void Unparse(const PimObjectListWithModifier &x) {
+    Walk(std::get<std::optional<PimDataModifier>>(x.t), ":");
+    Walk(std::get<PimObjectList>(x.t));
+  }
+  void Unparse(const PimDataModifier::Modifier &x) {
+    Word(PimDataModifier::EnumToString(x));
+  }
+  void Unparse(const PimObject &x) {
+    common::visit(common::visitors{
+                      [&](const Designator &y) { Walk(y); },
+                      [&](const Name &y) { Put("/"), Walk(y), Put("/"); },
+                  },
+        x.u);
+  }
+  void Unparse(const PimObjectList &x) { Walk(x.v, ","); }
+
+  void Unparse(const PimDefaultClause &x) {
+    switch (x.v) {
+    case llvm::pim::DefaultValue::PIM_Default_none:
+      Put("NONE");
+      break;
+    case llvm::pim::DefaultValue::PIM_Default_present:
+      Put("PRESENT");
+      break;
+    }
+  }
+  void Unparse(const PimClauseList &x) { Walk(" ", x.v, " "); }
+  void Unparse(const PimBeginLoopDirective &x) {
+    Walk(std::get<PimLoopDirective>(x.t));
+    Walk(std::get<PimClauseList>(x.t));
+  }
+  void Unparse(const PimBlockConstruct &x) {
+    BeginPim();
+    Word("!$PIM ");
+    Walk(std::get<PimBeginBlockDirective>(x.t));
+    Put("\n");
+    EndPim();
+    Walk(std::get<Block>(x.t), "");
+    BeginPim();
+    Word("!$ACC END ");
+    Walk(std::get<PimEndBlockDirective>(x.t));
+    Put("\n");
+    EndPim();
+  }
+  void Unparse(const PimLoopConstruct &x) {
+    BeginPim();
+    Word("!$PIM ");
+    Walk(std::get<PimBeginLoopDirective>(x.t));
+    Put("\n");
+    EndPim();
+    Walk(std::get<std::optional<DoConstruct>>(x.t));
+  }
+  void Unparse(const PimCombinedConstruct &x) {
+    BeginPim();
+    Word("!$PIM ");
+    Walk(std::get<PimBeginCombinedDirective>(x.t));
+    Put("\n");
+    EndPim();
+    Walk(std::get<std::optional<DoConstruct>>(x.t));
+    BeginPim();
+    Walk("!$PIM END ", std::get<std::optional<PimEndCombinedDirective>>(x.t),
+        "\n");
+    EndPim();
+  }
+  void Unparse(const PimRoutineConstruct &x) {
+    BeginPim();
+    Word("!$PIM ROUTINE");
+    Walk("(", std::get<std::optional<Name>>(x.t), ")");
+    Walk(std::get<PimClauseList>(x.t));
+    Put("\n");
+    EndPim();
+  }
+
   void Unparse(const OpenACCWaitConstruct &x) {
     BeginOpenACC();
     Word("!$ACC ");
@@ -2603,6 +2695,8 @@ private:
   void EndOpenMP() { openmpDirective_ = false; }
   void BeginOpenACC() { openaccDirective_ = true; }
   void EndOpenACC() { openaccDirective_ = false; }
+  void BeginPim() { pimDirective_ = true; }
+  void EndPim() { pimDirective_ = false; }
 
   // Call back to the traversal framework.
   template <typename T> void Walk(const T &x) {
@@ -2674,6 +2768,7 @@ private:
   bool capitalizeKeywords_{true};
   bool openaccDirective_{false};
   bool openmpDirective_{false};
+  bool pimDirective_{false};
   bool backslashEscapes_{false};
   preStatementType *preStatement_{nullptr};
   AnalyzedObjectsAsFortran *asFortran_{nullptr};
@@ -2681,7 +2776,7 @@ private:
 
 void UnparseVisitor::Put(char ch) {
   int sav = indent_;
-  if (openmpDirective_ || openaccDirective_) {
+  if (openmpDirective_ || openaccDirective_ || pimDirective_) {
     indent_ = 0;
   }
   if (column_ <= 1) {
@@ -2705,13 +2800,16 @@ void UnparseVisitor::Put(char ch) {
     } else if (openaccDirective_) {
       out_ << "!$ACC&";
       column_ = 8;
+    } else if (pimDirective_) {
+      out_ << "!$PIM&";
+      column_ = 8;
     } else {
       out_ << '&';
       column_ = indent_ + 3;
     }
   }
   out_ << ch;
-  if (openmpDirective_ || openaccDirective_) {
+  if (openmpDirective_ || openaccDirective_ || pimDirective_) {
     indent_ = sav;
   }
 }
diff --git a/flang/lib/Semantics/CMakeLists.txt b/flang/lib/Semantics/CMakeLists.txt
index 9e7c07b9c55f..3395f7e8249d 100644
--- a/flang/lib/Semantics/CMakeLists.txt
+++ b/flang/lib/Semantics/CMakeLists.txt
@@ -4,6 +4,7 @@ add_flang_library(FortranSemantics
   canonicalize-acc.cpp
   canonicalize-do.cpp
   canonicalize-omp.cpp
+  canonicalize-pim.cpp
   check-acc-structure.cpp
   check-allocate.cpp
   check-arithmeticif.cpp
@@ -46,6 +47,7 @@ add_flang_library(FortranSemantics
   DEPENDS
   acc_gen
   omp_gen
+  pim_gen
 
   LINK_LIBS
   FortranCommon
@@ -56,4 +58,5 @@ add_flang_library(FortranSemantics
   Support
   FrontendOpenMP
   FrontendOpenACC
+  FrontendPIM
 )
diff --git a/flang/lib/Semantics/canonicalize-do.cpp b/flang/lib/Semantics/canonicalize-do.cpp
index 6aab4b7bc49d..9bc30249f74a 100644
--- a/flang/lib/Semantics/canonicalize-do.cpp
+++ b/flang/lib/Semantics/canonicalize-do.cpp
@@ -130,6 +130,7 @@ private:
         stack.pop_back();
       } while (!stack.empty() && stack.back().label == currentLabel);
       i = --next;
+
     }
   }
 };
diff --git a/flang/lib/Semantics/canonicalize-pim.cpp b/flang/lib/Semantics/canonicalize-pim.cpp
new file mode 100644
index 000000000000..d069f27584cf
--- /dev/null
+++ b/flang/lib/Semantics/canonicalize-pim.cpp
@@ -0,0 +1,417 @@
+//===-- lib/Semantics/canonicalize-pim.cpp --------------------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "canonicalize-pim.h"
+#include "flang/Common/unwrap.h"
+#include "flang/Parser/message.h"
+#include "flang/Parser/parse-tree-visitor.h"
+#include "flang/Parser/parse-tree.h"
+#include "flang/Parser/tools.h"
+#include "flang/Semantics/tools.h"
+
+#include "llvm/Support/Debug.h"
+
+#define DEBUG_TYPE "canonicalize-pim"
+
+namespace Fortran::semantics {
+
+class CanonicalizationOfPim {
+public:
+  template <typename T> bool Pre(T &) { return true; }
+  template <typename T> void Post(T &) {}
+
+  bool inPimConstruct{false};
+  bool inPimDoConstruct{false};
+  parser::Block *originalBlock{nullptr};
+
+  bool Pre(parser::PimConstruct &) {
+    LLVM_DEBUG(llvm::dbgs() << "--> pre PimConstruct\n");
+    CHECK(!inPimConstruct && "nested pim directive");
+    inPimConstruct = true;
+    return true;
+  }
+
+
+// --> pre DoConstruct
+// --> rewrite AssignStmt
+// --> pre EndDoStmt
+// --> post EndDoStmt
+// --> post DoConstruct
+
+
+
+  bool Pre(parser::DoConstruct &doCons) {
+    // ExecutionPartConstruct -> ExecutableConstruct -> ActionStmt -> AssignmentStmt = 'c(int(i,kind=8))=a(int(i,kind=8))+b(int(i,kind=8))'
+    // | | | | | ExecutionPartConstruct -> ExecutableConstruct -> ActionStmt -> AssignmentStmt = 'c(int(i,kind=8))=a(int(i,kind=8))+b(int(i,kind=8))'
+    // | | | | | | Variable = 'c(int(i,kind=8))'
+    // | | | | | | | Designator -> DataRef -> ArrayElement
+    // | | | | | | | | DataRef -> Name = 'c'
+    // | | | | | | | | SectionSubscript -> Integer -> Expr = 'i'
+    // | | | | | | | | | Designator -> DataRef -> Name = 'i'
+    // | | | | | | Expr = 'a(int(i,kind=8))+b(int(i,kind=8))'
+    // | | | | | | | Add
+    // | | | | | | | | Expr = 'a(int(i,kind=8))'
+    // | | | | | | | | | Designator -> DataRef -> ArrayElement
+    // | | | | | | | | | | DataRef -> Name = 'a'
+    // | | | | | | | | | | SectionSubscript -> Integer -> Expr = 'i'
+    // | | | | | | | | | | | Designator -> DataRef -> Name = 'i'
+    // | | | | | | | | Expr = 'b(int(i,kind=8))'
+    // | | | | | | | | | Designator -> DataRef -> ArrayElement
+    // | | | | | | | | | | DataRef -> Name = 'b'
+    // | | | | | | | | | | SectionSubscript -> Integer -> Expr = 'i'
+    // | | | | | | | | | | | Designator -> DataRef -> Name = 'i'
+
+    // for (parser::ExecutionPartConstruct &epc :
+    //     std::get<parser::Block>(doCons.t)) {
+    //   LLVM_DEBUG(llvm::dbgs() << "----> ExecutionPartConstruct iter\n");
+    //   if (auto *executableCons{common::Unwrap<parser::ExecutableConstruct>(epc.u)}) {
+    //     LLVM_DEBUG(llvm::dbgs() << "------> ExecutableConstruct iter\n");
+
+    //     if (auto *actionStmt{
+    //         common::Unwrap<parser::Statement<parser::ActionStmt>>(executableCons->u)}) {
+    //       LLVM_DEBUG(llvm::dbgs() << "--------> ActionStmt iter\n");
+    //       // if (auto *assignmentStmt{parser::Unwrap<common::Indirection<parser::AssignmentStmt>>(actionStmt->statement.u)}) {
+    //       if (auto *assignmentStmt{parser::Unwrap<parser::AssignmentStmt>(actionStmt->statement.u)}) {
+    //         LLVM_DEBUG(llvm::dbgs() << "----------> AssignmentStmt iter\n");
+
+    //         parser::Variable &var{std::get<parser::Variable>(assignmentStmt->t)};
+    //         parser::Expr &expr{std::get<parser::Expr>(assignmentStmt->t)};
+    //         if (auto *addExpr{parser::Unwrap<parser::Expr::Add>(expr.u)}) {
+    //           // parser::PimAdd pimAdd{
+    //           //   std::make_tuple(std::move(var), std::move(expr))};
+    //           LLVM_DEBUG(llvm::dbgs() << "--> rewrite Add in PIM\n");
+    //           auto x = std::move(epc);
+    //           (void)x;
+    //         }
+    //       }
+    //     }
+    //   }
+    // }
+    parser::Block& doBlock{std::get<parser::Block>(doCons.t)};
+    parser::Block::iterator next{doBlock.begin()};
+    // iterate list of ExecutionPartConstruct in DoConstruct block
+    while (next != doBlock.end()) {
+      bool removed{false};
+      LLVM_DEBUG(llvm::dbgs() << "----> ExecutionPartConstruct iter\n");
+      if (auto *executableCons{
+              common::Unwrap<parser::ExecutableConstruct>(next->u)}) {
+        LLVM_DEBUG(llvm::dbgs() << "------> ExecutableConstruct iter\n");
+
+        if (auto *actionStmt{
+                common::Unwrap<parser::Statement<parser::ActionStmt>>(
+                    executableCons->u)}) {
+          LLVM_DEBUG(llvm::dbgs() << "--------> ActionStmt iter\n");
+          // if (auto
+          // *assignmentStmt{parser::Unwrap<common::Indirection<parser::AssignmentStmt>>(actionStmt->statement.u)})
+          // {
+          if (auto *assignmentStmt{parser::Unwrap<parser::AssignmentStmt>(
+                  actionStmt->statement.u)}) {
+            LLVM_DEBUG(llvm::dbgs() << "----------> AssignmentStmt iter\n");
+
+            parser::Variable &var{
+                std::get<parser::Variable>(assignmentStmt->t)};
+            parser::Expr &expr{std::get<parser::Expr>(assignmentStmt->t)};
+            if (auto *addExpr{parser::Unwrap<parser::Expr::Add>(expr.u)}) {
+              parser::PimAdd pimAdd{
+                std::make_tuple(std::move(var), std::move(expr))};
+              LLVM_DEBUG(llvm::dbgs() << "--> rewrite Add in PIM\n");
+              // removed = true;
+
+              parser::PimOperation pimOp{std::move(pimAdd)};
+              // executableCons->u = std::move(pimOp);
+
+              doBlock.erase(next++);
+              doBlock.insert(next,
+                  parser::ExecutionPartConstruct{
+                      parser::ExecutableConstruct{std::move(pimOp)}});
+              return true;
+
+              // doBlock.insert(next, pimOp);
+              // auto x = std::move(epc);
+              // (void)x;
+            }
+          }
+        }
+      }
+      if (!removed) {
+      ++next;
+      }
+    }
+
+    CHECK(!inPimDoConstruct && "support nested loops");
+    if (inPimConstruct) {
+      inPimDoConstruct = true;
+      originalBlock = &std::get<parser::Block>(doCons.t);
+
+      for (parser::ExecutionPartConstruct &epc : *originalBlock) {
+        if (auto* actionStmt{common::Unwrap<parser::ActionStmt>(epc.u)}) {
+          if (auto *assignmentStmt{parser::Unwrap<parser::AssignmentStmt>(actionStmt->u)}) {
+            LLVM_DEBUG(llvm::dbgs() << "--> FOUND2 one assign\n");
+          }
+        }
+      }
+    }
+
+    LLVM_DEBUG(llvm::dbgs() << "--> pre DoConstruct\n");
+    return true;
+  }
+
+  void Post(parser::DoConstruct &) {
+    inPimConstruct = false;
+    inPimDoConstruct = false;
+    LLVM_DEBUG(llvm::dbgs() << "--> post DoConstruct\n");
+  }
+
+  void ReplaceOp(parser::Block::iterator it) {
+    LLVM_DEBUG(llvm::dbgs() << "--> replace op?\n");
+  }
+
+  void Post(parser::AssignmentStmt &st) {
+    if (inPimDoConstruct) {
+      parser::Variable &var{std::get<parser::Variable>(st.t)};
+      parser::Expr &expr{std::get<parser::Expr>(st.t)};
+      if (auto *addExpr{parser::Unwrap<parser::Expr::Add>(expr.u)}) {
+        // parser::PimAdd pimAdd{
+        //   std::make_tuple(std::move(var), std::move(expr))};
+        LLVM_DEBUG(llvm::dbgs() << "--> rewrite Add in PIM\n");
+      } else if (auto *mulExpr{parser::Unwrap<parser::Expr::Multiply>(expr.u)}) {
+        LLVM_DEBUG(llvm::dbgs() << "--> rewrite Mul in PIM\n");
+      }
+      LLVM_DEBUG(llvm::dbgs() << "--> rewrite AssignStmt in PIM\n");
+    }
+  }
+
+  bool Pre(parser::Block &) {
+    LLVM_DEBUG(llvm::dbgs() << "--> pre Block\n");
+    return true;
+  }
+
+  void Post(parser::Block &block) {
+    LLVM_DEBUG(llvm::dbgs() << "--> post Block\n");
+    for (auto it{block.begin()}; it != block.end(); ++it) {
+      if (inPimDoConstruct) {
+        ReplaceOp(it);
+      } else if (auto *pimOp{parser::Unwrap<parser::PimOperation>(*it)}) {
+        LLVM_DEBUG(llvm::dbgs() << "  --> PimOperation\n");
+      } else if (auto *pimLoop{parser::Unwrap<parser::PimLoopConstruct>(*it)}) {
+        LLVM_DEBUG(llvm::dbgs() << "  --> PimLoopConstruct\n");
+        RewritePimLoopConstruct(*pimLoop, block, it);
+      } else if (auto *pimCombined{
+                     parser::Unwrap<parser::PimCombinedConstruct>(*it)}) {
+        LLVM_DEBUG(llvm::dbgs() << "  --> PimCombinedConstruct\n");
+        RewritePimCombinedConstruct(*pimCombined, block, it);
+      } else if (auto *endDir{
+                     parser::Unwrap<parser::PimEndCombinedDirective>(*it)}) {
+        LLVM_DEBUG(llvm::dbgs() << "  --> PimEndCombinedDirective\n");
+        // Unmatched PimEndCombinedDirective
+        messages_.Say(endDir->v.source,
+            "The %s directive must follow the DO loop associated with the "
+            "loop construct"_err_en_US,
+            parser::ToUpperCaseLetters(endDir->v.source.ToString()));
+      } else {
+        LLVM_DEBUG(llvm::dbgs() << "  --> unhandled operation\n");
+      }
+    }
+  }
+
+  CanonicalizationOfPim(parser::Messages &messages) : messages_{messages} {}
+
+private:
+  void RewriteDoConstruct(parser::DoConstruct &x, parser::Block &block,
+      parser::Block::iterator it) {
+    auto &doBlock{std::get<parser::Block>(x.t)};
+// | | | | Block
+// | | | | | ExecutionPartConstruct -> ExecutableConstruct -> ActionStmt -> AssignmentStmt = 'c(int(i,kind=8))=a(int(i,kind=8))+b(int(i,kind=8))'
+// | | | | | | Variable = 'c(int(i,kind=8))'
+// | | | | | | | Designator -> DataRef -> ArrayElement
+// | | | | | | | | DataRef -> Name = 'c'
+// | | | | | | | | SectionSubscript -> Integer -> Expr = 'i'
+// | | | | | | | | | Designator -> DataRef -> Name = 'i'
+// | | | | | | Expr = 'a(int(i,kind=8))+b(int(i,kind=8))'
+// | | | | | | | Add
+// | | | | | | | | Expr = 'a(int(i,kind=8))'
+// | | | | | | | | | Designator -> DataRef -> ArrayElement
+// | | | | | | | | | | DataRef -> Name = 'a'
+// | | | | | | | | | | SectionSubscript -> Integer -> Expr = 'i'
+// | | | | | | | | | | | Designator -> DataRef -> Name = 'i'
+// | | | | | | | | Expr = 'b(int(i,kind=8))'
+// | | | | | | | | | Designator -> DataRef -> ArrayElement
+// | | | | | | | | | | DataRef -> Name = 'b'
+// | | | | | | | | | | SectionSubscript -> Integer -> Expr = 'i'
+// | | | | | | | | | | | Designator -> DataRef -> Name = 'i'    for (auto &st : doBlock) {
+    // for (auto &st : block) {
+    //   if (auto *executionPartConstruct{
+    //           parser::Unwrap<parser::ExecutionPartConstruct>(st)}) {
+    //     auto &executableConstruct{
+    //         std::get<parser::ExecutableConstruct>(executionPartConstruct->u)};
+    //     auto &actionStmt{std::get<parser::ActionStmt>(executableConstruct.u)};
+    //     auto &assignStmt{std::get<parser::AssignmentStmt>(actionStmt.u)};
+    //     auto &assignVar{std::get<parser::Variable>(assignStmt.t)};
+    //     auto &assignVarDesignator{std::get<parser::Designator>(assignVar.u)};
+    //     auto &assignVarDataRef{
+    //         std::get<parser::DataRef>(assignVarDesignator.u)};
+    //     auto &assignVarName{std::get<parser::Name>(assignVarDataRef.u)};
+    //     LLVM_DEBUG(llvm::dbgs() << "--> rewrite AssignStmt to "
+    //                             << assignVarName.ToString() << " \n");
+
+    //     auto &expr{std::get<parser::Expr>(assignStmt.t)};
+    //     //   if (auto &addExpr{std::get<parser::Expr::Add>(expr.u)}) {
+    //     // }
+    //     // LLVM_DEBUG(llvm::dbgs() << "--> rewrite AssignStmt block\n");
+    //   }
+    // }
+  }
+  void RewritePimLoopConstruct(parser::PimLoopConstruct &x,
+      parser::Block &block, parser::Block::iterator it) {
+
+    LLVM_DEBUG(llvm::dbgs() << "--> RewritePimLoopConstruct\n");
+    // Check the sequence of DoConstruct in the same iteration
+    //
+    // Original:
+    //   ExecutableConstruct -> PimConstruct -> PimLoopConstruct
+    //     PimBeginLoopDirective
+    //   ExecutableConstruct -> DoConstruct
+    //
+    // After rewriting:
+    //   ExecutableConstruct -> PimConstruct -> PimLoopConstruct
+    //     PimBeginLoopDirective
+    //     DoConstruct
+
+    parser::Block::iterator nextIt;
+    auto &beginDir{std::get<parser::PimBeginLoopDirective>(x.t)};
+    auto &dir{std::get<parser::PimLoopDirective>(beginDir.t)};
+
+    nextIt = it;
+    if (++nextIt != block.end()) {
+      if (auto *doCons{parser::Unwrap<parser::DoConstruct>(*nextIt)}) {
+        if (doCons->GetLoopControl()) {
+          RewriteDoConstruct(*doCons, block, it);
+          // move DoConstruct
+          std::get<std::optional<parser::DoConstruct>>(x.t) =
+              std::move(*doCons);
+          nextIt = block.erase(nextIt);
+        } else {
+          messages_.Say(dir.source,
+              "DO loop after the %s directive must have loop control"_err_en_US,
+              parser::ToUpperCaseLetters(dir.source.ToString()));
+        }
+        // CheckDoConcurrentClauseRestriction<parser::OpenACCLoopConstruct,
+        //     parser::AccBeginLoopDirective>(x);
+        // CheckTileClauseRestriction<parser::OpenACCLoopConstruct,
+        //     parser::AccBeginLoopDirective>(x);
+
+        return; // found do-loop
+      }
+    }
+    messages_.Say(dir.source,
+        "A DO loop must follow the %s directive"_err_en_US,
+        parser::ToUpperCaseLetters(dir.source.ToString()));
+  }
+
+  void RewritePimCombinedConstruct(parser::PimCombinedConstruct &x,
+      parser::Block &block, parser::Block::iterator it) {
+    // Check the sequence of DoConstruct in the same iteration
+    //
+    // Original:
+    //   ExecutableConstruct -> PimConstruct -> PimCombinedConstruct
+    //     PIMBeginCombinedDirective
+    //   ExecutableConstruct -> DoConstruct
+    //   ExecutableConstruct -> PimEndCombinedDirective (if available)
+    //
+    // After rewriting:
+    //   ExecutableConstruct -> PimConstruct -> PimCombinedConstruct
+    //     PIMBeginCombinedDirective
+    //     DoConstruct
+    //     PimEndCombinedDirective (if available)
+    parser::Block::iterator nextIt;
+    auto &beginDir{std::get<parser::PimBeginCombinedDirective>(x.t)};
+    auto &dir{std::get<parser::PimCombinedDirective>(beginDir.t)};
+
+    nextIt = it;
+    if (++nextIt != block.end()) {
+      if (auto *doCons{parser::Unwrap<parser::DoConstruct>(*nextIt)}) {
+        if (doCons->GetLoopControl()) {
+          RewriteDoConstruct(*doCons, block, it);
+          // move DoConstruct
+          std::get<std::optional<parser::DoConstruct>>(x.t) =
+              std::move(*doCons);
+          nextIt = block.erase(nextIt);
+          // try to match PimEndCombinedDirective
+          if (nextIt != block.end()) {
+            if (auto *endDir{
+                    parser::Unwrap<parser::PimEndCombinedDirective>(*nextIt)}) {
+              std::get<std::optional<parser::PimEndCombinedDirective>>(x.t) =
+                  std::move(*endDir);
+              block.erase(nextIt);
+            }
+          }
+        } else {
+          messages_.Say(dir.source,
+              "DO loop after the %s directive must have loop control"_err_en_US,
+              parser::ToUpperCaseLetters(dir.source.ToString()));
+        }
+
+        // CheckDoConcurrentClauseRestriction<parser::PimCombinedConstruct,
+        //     parser::PimBeginCombinedDirective>(x);
+        // CheckTileClauseRestriction<parser::PimCombinedConstruct,
+        //     parser::PimBeginCombinedDirective>(x);
+
+        return; // found do-loop
+      }
+    }
+    messages_.Say(dir.source,
+        "A DO loop must follow the %s directive"_err_en_US,
+        parser::ToUpperCaseLetters(dir.source.ToString()));
+  }
+
+  parser::Messages &messages_;
+};
+
+class CanonicalizationOfPimVerify {
+public:
+  template <typename T> bool Pre(T &) { return true; }
+  template <typename T> void Post(T &) {}
+
+  void Post(parser::Block &block) {
+    LLVM_DEBUG(llvm::dbgs() << "--> post Block\n");
+    for (auto it{block.begin()}; it != block.end(); ++it) {
+      if (auto *pimOp{parser::Unwrap<parser::PimOperation>(*it)}) {
+        LLVM_DEBUG(llvm::dbgs() << "  --> PimOperation\n");
+      }
+      else if (auto *pimLoop{parser::Unwrap<parser::PimLoopConstruct>(*it)}) {
+        LLVM_DEBUG(llvm::dbgs() << "  --> PimLoopConstruct\n");
+      }
+      else if (auto *pimCombined{
+                   parser::Unwrap<parser::PimCombinedConstruct>(*it)}) {
+        LLVM_DEBUG(llvm::dbgs() << "  --> PimCombinedConstruct\n");
+      }
+      else if (auto *endDir{
+                   parser::Unwrap<parser::PimEndCombinedDirective>(*it)}) {
+        LLVM_DEBUG(llvm::dbgs() << "  --> PimEndCombinedDirective\n");
+      }
+      else {
+        LLVM_DEBUG(llvm::dbgs() << "  --> unhandled operation\n");
+      }
+    }
+  }
+
+  CanonicalizationOfPimVerify(parser::Messages &messages) : messages_{messages} {}
+private:
+  parser::Messages &messages_;
+};
+
+bool CanonicalizePim(parser::Messages &messages, parser::Program &program) {
+  CanonicalizationOfPim pim{messages};
+  Walk(program, pim);
+  CanonicalizationOfPimVerify pimVerify{messages};
+  LLVM_DEBUG(llvm::dbgs() << "RUN CanonicalizationOfPimVerify\n");
+  Walk(program, pimVerify);
+  return !messages.AnyFatalError();
+}
+
+} // namespace Fortran::semantics
diff --git a/flang/lib/Semantics/canonicalize-pim.h b/flang/lib/Semantics/canonicalize-pim.h
new file mode 100644
index 000000000000..e8928cba2d32
--- /dev/null
+++ b/flang/lib/Semantics/canonicalize-pim.h
@@ -0,0 +1,21 @@
+//===-- lib/Semantics/canonicalize-pim.h ------------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef FORTRAN_SEMANTICS_CANONICALIZE_PIM_H_
+#define FORTRAN_SEMANTICS_CANONICALIZE_PIM_H_
+
+namespace Fortran::parser {
+struct Program;
+class Messages;
+} // namespace Fortran::parser
+
+namespace Fortran::semantics {
+bool CanonicalizePim(parser::Messages &messages, parser::Program &program);
+}
+
+#endif // FORTRAN_SEMANTICS_CANONICALIZE_PIM_H_
diff --git a/flang/lib/Semantics/check-pim-structure.h b/flang/lib/Semantics/check-pim-structure.h
new file mode 100644
index 000000000000..66adf6eec6a5
--- /dev/null
+++ b/flang/lib/Semantics/check-pim-structure.h
@@ -0,0 +1,48 @@
+#pragma once
+
+#include "check-directive-structure.h"
+#include "flang/Common/enum-set.h"
+#include "flang/Parser/parse-tree.h"
+#include "flang/Semantics/semantics.h"
+#include "llvm/Frontend/Pim/PIM.h.inc"
+
+using PimDirectiveSet = Fortran::common::EnumSet<llvm::pim::Directive,
+    llvm::pim::Directive_enumSize>;
+
+using PimClauseSet =
+    Fortran::common::EnumSet<llvm::pim::Clause, llvm::pim::Clause_enumSize>;
+
+#define GEN_FLANG_DIRECTIVE_CLAUSE_SETS
+#include "llvm/Frontend/Pim/PIM.inc"
+
+namespace Fortran::semantics {
+
+class PimStructureChecker
+    : public DirectiveStructureChecker<llvm::pim::Directive, llvm::pim::Clause,
+          parser::PimClause, llvm::pim::Clause_enumSize> {
+public:
+  PimStructureChecker(SemanticsContext &context)
+      : DirectiveStructureChecker(context,
+#define GEN_FLANG_DIRECTIVE_CLAUSE_MAP
+#include "llvm/Frontend/Pim/PIM.inc"
+        ) {
+  }
+
+  // Clauses
+  void Enter(const parser::PimClause &) {}
+  void Leave(const parser::PimClause &) {}
+
+  void Enter(const parser::PimClauseList &) {}
+  void Leave(const parser::PimClauseList &) {}
+
+  // void Enter(const parser::PimClause::Default &) {}
+  void Leave(const parser::PimClause::Default &) {}
+
+  // void Enter(const parser::PimClause::Unknown &) {}
+  void Leave(const parser::PimClause::Unknown &) {}
+
+#define GEN_FLANG_CLAUSE_CHECK_ENTER
+#include "llvm/Frontend/Pim/PIM.inc"
+};
+
+} // namespace Fortran::semantics
diff --git a/flang/lib/Semantics/resolve-directives.cpp b/flang/lib/Semantics/resolve-directives.cpp
index 21cb42ee37c6..afe28fb0e565 100644
--- a/flang/lib/Semantics/resolve-directives.cpp
+++ b/flang/lib/Semantics/resolve-directives.cpp
@@ -9,6 +9,7 @@
 #include "resolve-directives.h"
 
 #include "check-acc-structure.h"
+#include "check-pim-structure.h"
 #include "check-omp-structure.h"
 #include "resolve-names-utils.h"
 #include "flang/Common/idioms.h"
@@ -229,6 +230,20 @@ private:
       const llvm::acc::Clause clause, const parser::AccObjectList &objectList);
 };
 
+
+class PimAttributeVisitor : DirectiveAttributeVisitor<llvm::pim::Directive> {
+public:
+  explicit PimAttributeVisitor(SemanticsContext &context)
+      : DirectiveAttributeVisitor(context) {}
+
+  template <typename A> void Walk(const A &x) { parser::Walk(x, *this); }
+  template <typename A> bool Pre(const A &) { return true; }
+  template <typename A> void Post(const A &) {}
+};
+
+
+
+
 // Data-sharing and Data-mapping attributes for data-refs in OpenMP construct
 class OmpAttributeVisitor : DirectiveAttributeVisitor<llvm::omp::Directive> {
 public:
@@ -1772,6 +1787,13 @@ void ResolveOmpParts(
   }
 }
 
+void ResolvePimParts(
+    SemanticsContext &context, const parser::ProgramUnit &node) {
+  if (context.IsEnabled(common::LanguageFeature::Pim)) {
+    PimAttributeVisitor{context}.Walk(node);
+  }
+}
+
 void OmpAttributeVisitor::CheckDataCopyingClause(
     const parser::Name &name, const Symbol &symbol, Symbol::Flag ompFlag) {
   const auto *checkSymbol{&symbol};
diff --git a/flang/lib/Semantics/resolve-directives.h b/flang/lib/Semantics/resolve-directives.h
index 6ba7a0625294..8f0409f99d1b 100644
--- a/flang/lib/Semantics/resolve-directives.h
+++ b/flang/lib/Semantics/resolve-directives.h
@@ -21,6 +21,7 @@ class SemanticsContext;
 // Name resolution for OpenACC and OpenMP directives
 void ResolveAccParts(SemanticsContext &, const parser::ProgramUnit &);
 void ResolveOmpParts(SemanticsContext &, const parser::ProgramUnit &);
+void ResolvePimParts(SemanticsContext &, const parser::ProgramUnit &);
 
 } // namespace Fortran::semantics
 #endif
diff --git a/flang/lib/Semantics/resolve-names.cpp b/flang/lib/Semantics/resolve-names.cpp
index b6185e2517d6..e45c8f5df972 100644
--- a/flang/lib/Semantics/resolve-names.cpp
+++ b/flang/lib/Semantics/resolve-names.cpp
@@ -7413,6 +7413,7 @@ bool ResolveNamesVisitor::Pre(const parser::ProgramUnit &x) {
   ResolveExecutionParts(root);
   ResolveAccParts(context(), x);
   ResolveOmpParts(context(), x);
+  ResolvePimParts(context(), x);
   return false;
 }
 
diff --git a/flang/lib/Semantics/semantics.cpp b/flang/lib/Semantics/semantics.cpp
index 20fd0ab6c6d4..7e8a484a0e96 100644
--- a/flang/lib/Semantics/semantics.cpp
+++ b/flang/lib/Semantics/semantics.cpp
@@ -11,7 +11,9 @@
 #include "canonicalize-acc.h"
 #include "canonicalize-do.h"
 #include "canonicalize-omp.h"
+#include "canonicalize-pim.h"
 #include "check-acc-structure.h"
+#include "check-pim-structure.h"
 #include "check-allocate.h"
 #include "check-arithmeticif.h"
 #include "check-case.h"
@@ -491,6 +493,7 @@ bool Semantics::Perform() {
       parser::CanonicalizeDo(program_) && // force line break
       CanonicalizeAcc(context_.messages(), program_) &&
       CanonicalizeOmp(context_.messages(), program_) &&
+      CanonicalizePim(context_.messages(), program_) &&
       PerformStatementSemantics(context_, program_) &&
       ModFileWriter{context_}.WriteAll();
 }
diff --git a/flang/test/Driver/driver-help-hidden.f90 b/flang/test/Driver/driver-help-hidden.f90
index 929b64e5455f..c185b26ead97 100644
--- a/flang/test/Driver/driver-help-hidden.f90
+++ b/flang/test/Driver/driver-help-hidden.f90
@@ -44,6 +44,7 @@
 ! CHECK-NEXT: -fno-integrated-as     Disable the integrated assembler
 ! CHECK-NEXT: -fopenacc              Enable OpenACC
 ! CHECK-NEXT: -fopenmp               Parse OpenMP pragmas and generate parallel code.
+! CHECK-NEXT: -fpim                  Enable Pim
 ! CHECK-NEXT: -fxor-operator         Enable .XOR. as a synonym of .NEQV.
 ! CHECK-NEXT: -help     Display available options
 ! CHECK-NEXT: -I <dir>               Add directory to the end of the list of include search paths
diff --git a/flang/test/Driver/driver-help.f90 b/flang/test/Driver/driver-help.f90
index fd388ca9959b..c0eb9bdb09a9 100644
--- a/flang/test/Driver/driver-help.f90
+++ b/flang/test/Driver/driver-help.f90
@@ -42,6 +42,7 @@
 ! HELP-NEXT: -fno-integrated-as      Disable the integrated assembler
 ! HELP-NEXT: -fopenacc              Enable OpenACC
 ! HELP-NEXT: -fopenmp               Parse OpenMP pragmas and generate parallel code.
+! HELP-NEXT: -fpim                  Enable Pim
 ! HELP-NEXT: -fxor-operator         Enable .XOR. as a synonym of .NEQV.
 ! HELP-NEXT: -help                  Display available options
 ! HELP-NEXT: -I <dir>               Add directory to the end of the list of include search paths
@@ -119,6 +120,7 @@
 ! HELP-FC1-NEXT: -fno-reformat          Dump the cooked character stream in -E mode
 ! HELP-FC1-NEXT: -fopenacc              Enable OpenACC
 ! HELP-FC1-NEXT: -fopenmp               Parse OpenMP pragmas and generate parallel code.
+! HELP-FC1-NEXT: -fpim                  Enable Pim
 ! HELP-FC1-NEXT: -fxor-operator         Enable .XOR. as a synonym of .NEQV.
 ! HELP-FC1-NEXT: -help                  Display available options
 ! HELP-FC1-NEXT: -init-only             Only execute frontend initialization
diff --git a/flang/test/Lower/Pim/pre-fir-tree01.f90 b/flang/test/Lower/Pim/pre-fir-tree01.f90
new file mode 100644
index 000000000000..fb0dd7773e90
--- /dev/null
+++ b/flang/test/Lower/Pim/pre-fir-tree01.f90
@@ -0,0 +1,46 @@
+! RUN: %flang_fc1 -fpim -fdebug-dump-parse-tree %s 2>&1 | FileCheck %s --check-prefix=PARSE_TREE
+! RUN: %flang_fc1 -fpim -fdebug-dump-pft %s 2>&1 | FileCheck %s --check-prefix=PFT
+! RUN: bbc -fpim -pft-test %s 2>&1 | FileCheck %s --check-prefix=PFT
+
+! Test structure of the AST/Pre-FIR tree with PIm
+
+!
+! AST
+!
+! PARSE_TREE: | | ExecutionPartConstruct -> ExecutableConstruct -> PimConstruct -> PimCombinedConstruct
+! PARSE_TREE-NEXT: | | | PimBeginCombinedDirective
+! PARSE_TREE-NEXT: | | | | PimCombinedDirective -> llvm::pim::Directive = parallel loop
+! PARSE_TREE-NEXT: | | | | PimClauseList ->
+! PARSE_TREE-NEXT: | | | DoConstruct
+
+
+!
+! PFT
+!
+
+! PFT: 1 Subroutine sub1: subroutine sub1(a, b, n)
+! PFT-NEXT:   1 AssignmentStmt: i = 1
+! PFT-NEXT:   2 <<PimConstruct>>
+! PFT-NEXT:     <<DoConstruct>> -> 6
+! PFT-NEXT:       3 NonLabelDoStmt -> 5: do i = 1, n
+! PFT-NEXT:       4 ^AssignmentStmt: b(i) = exp(a(i))
+! PFT-NEXT:       5 EndDoStmt -> 3: end do
+! PFT-NEXT:     <<End DoConstruct>>
+! PFT-NEXT:     6 ContinueStmt
+! PFT-NEXT:   <<End PimConstruct>>
+! PFT-NEXT:   7 EndSubroutineStmt: end subroutine
+! PFT-NEXT: End Subroutine sub1
+
+!-------
+! INPUT
+!-------
+
+subroutine sub1(a, b, n)
+  real(2) :: a(:), b(:)
+  integer :: n, i
+  i = 1
+  !$pim parallel loop
+  do i = 1, n
+    b(i) = exp(a(i))
+  end do
+end subroutine
diff --git a/flang/test/Lower/Pim/pre-fir-tree02.f90 b/flang/test/Lower/Pim/pre-fir-tree02.f90
new file mode 100644
index 000000000000..a455d9131659
--- /dev/null
+++ b/flang/test/Lower/Pim/pre-fir-tree02.f90
@@ -0,0 +1,52 @@
+! RUN: %flang_fc1 -fpim -fdebug-dump-parse-tree %s 2>&1 | FileCheck %s --check-prefix=PARSE_TREE
+! RUN: %flang_fc1 -fpim -fdebug-dump-pft %s 2>&1 | FileCheck %s --check-prefix=PFT
+! RUN: bbc -fpim -pft-test %s 2>&1 | FileCheck %s --check-prefix=PFT
+
+! Test structure of the AST/Pre-FIR tree with Pim compute region modifiers -
+! copyin/copyout.
+
+!
+! AST
+!
+
+! PARSE_TREE: | | ExecutionPartConstruct -> ExecutableConstruct -> PimConstruct -> PimCombinedConstruct
+! PARSE_TREE-NEXT: | | | PimBeginCombinedDirective
+! PARSE_TREE-NEXT: | | | | PimCombinedDirective -> llvm::pim::Directive = parallel loop
+! PARSE_TREE-NEXT: | | | | PimClauseList -> PimClause -> Copyin -> PimObjectListWithModifier
+! PARSE_TREE-NEXT: | | | | | PimObjectList -> PimObject -> Designator -> DataRef -> Name = 'a'
+! PARSE_TREE-NEXT: | | | | | PimObject -> Designator -> DataRef -> Name = 'b'
+! PARSE_TREE-NEXT: | | | | PimClause -> Copyout -> PimObjectListWithModifier
+! PARSE_TREE-NEXT: | | | | | PimObjectList -> PimObject -> Designator -> DataRef -> Name = 'c'
+! PARSE_TREE-NEXT: | | | DoConstruct
+
+!
+! PFT
+!
+
+! PFT: 1 Subroutine sub1: subroutine sub1(a, b, c, n)
+! PFT-NEXT:   1 AssignmentStmt: i = 0
+! PFT-NEXT:   2 <<PimConstruct>>
+! PFT-NEXT:     <<DoConstruct>> -> 6
+! PFT-NEXT:       3 NonLabelDoStmt -> 5: do i = 1, n
+! PFT-NEXT:       4 ^AssignmentStmt: c(i) = a(i) + b(i)
+! PFT-NEXT:       5 EndDoStmt -> 3: end do
+! PFT-NEXT:     <<End DoConstruct>>
+! PFT-NEXT:     6 ContinueStmt
+! PFT-NEXT:   <<End PimConstruct>>
+! PFT-NEXT:   7 EndSubroutineStmt: end subroutine
+! PFT-NEXT: End Subroutine sub1
+
+
+!-------
+! INPUT
+!-------
+
+subroutine sub1(a, b, c, n)
+  real :: a(:), b(:), c(:)
+  integer :: n, i
+  i = 0
+  !$pim parallel loop copyin(a, b) copyout(c)
+  do i = 1, n
+    c(i) = a(i) + b(i)
+  end do
+end subroutine
diff --git a/flang/tools/bbc/bbc.cpp b/flang/tools/bbc/bbc.cpp
index 133da66b7355..275f3d2e32dd 100644
--- a/flang/tools/bbc/bbc.cpp
+++ b/flang/tools/bbc/bbc.cpp
@@ -124,6 +124,9 @@ static llvm::cl::opt<bool> enableOpenACC("fopenacc",
                                          llvm::cl::desc("enable openacc"),
                                          llvm::cl::init(false));
 
+static llvm::cl::opt<bool> enablePim("fpim", llvm::cl::desc("enable pim"),
+                                     llvm::cl::init(false));
+
 #define FLANG_EXCLUDE_CODEGEN
 #include "flang/Tools/CLOptions.inc"
 
@@ -319,6 +322,13 @@ int main(int argc, char **argv) {
     options.predefinitions.emplace_back("_OPENACC", "201911");
   }
 
+  // enable parsing of Pim
+  if (enablePim) {
+    options.features.Enable(Fortran::common::LanguageFeature::Pim);
+    options.predefinitions.emplace_back("__pim__"s, "1"s);
+  }
+
+
   Fortran::common::IntrinsicTypeDefaultKinds defaultKinds;
   Fortran::parser::AllSources allSources;
   Fortran::parser::AllCookedSources allCookedSources(allSources);
diff --git a/flang/tools/f18-parse-demo/CMakeLists.txt b/flang/tools/f18-parse-demo/CMakeLists.txt
index df1f1d24a55e..4ec9c52979f4 100644
--- a/flang/tools/f18-parse-demo/CMakeLists.txt
+++ b/flang/tools/f18-parse-demo/CMakeLists.txt
@@ -1,6 +1,7 @@
 set(LLVM_LINK_COMPONENTS
   FrontendOpenACC
   FrontendOpenMP
+  FrontendPIM
   Support
   )
 
diff --git a/flang/tools/f18/CMakeLists.txt b/flang/tools/f18/CMakeLists.txt
index e7a826e0dda5..9d430f27b364 100644
--- a/flang/tools/f18/CMakeLists.txt
+++ b/flang/tools/f18/CMakeLists.txt
@@ -1,6 +1,7 @@
 set(LLVM_LINK_COMPONENTS
   FrontendOpenACC
   FrontendOpenMP
+  FrontendPIM
   Support
   )
 
diff --git a/llvm/include/llvm/Frontend/CMakeLists.txt b/llvm/include/llvm/Frontend/CMakeLists.txt
index ea66917b8936..09ebad6fa23a 100644
--- a/llvm/include/llvm/Frontend/CMakeLists.txt
+++ b/llvm/include/llvm/Frontend/CMakeLists.txt
@@ -1,2 +1,3 @@
 add_subdirectory(OpenACC)
 add_subdirectory(OpenMP)
+add_subdirectory(Pim)
diff --git a/llvm/include/llvm/Frontend/Pim/CMakeLists.txt b/llvm/include/llvm/Frontend/Pim/CMakeLists.txt
new file mode 100644
index 000000000000..a9bc1d9ec9ea
--- /dev/null
+++ b/llvm/include/llvm/Frontend/Pim/CMakeLists.txt
@@ -0,0 +1,4 @@
+set(LLVM_TARGET_DEFINITIONS PIM.td)
+tablegen(LLVM PIM.h.inc --gen-directive-decl)
+tablegen(LLVM PIM.inc --gen-directive-impl)
+add_public_tablegen_target(pim_gen)
diff --git a/llvm/include/llvm/Frontend/Pim/PIM.td b/llvm/include/llvm/Frontend/Pim/PIM.td
new file mode 100644
index 000000000000..d08c97400878
--- /dev/null
+++ b/llvm/include/llvm/Frontend/Pim/PIM.td
@@ -0,0 +1,109 @@
+//===-- PIM.td - PIM directive definition file -------------*- tablegen -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This is the definition file for PIM directives and clauses.
+//
+//===----------------------------------------------------------------------===//
+
+include "llvm/Frontend/Directive/DirectiveBase.td"
+
+def PIM : DirectiveLanguage {
+  let name = "PIM";
+  let cppNamespace = "pim"; // final namespace will be llvm::pim
+  let directivePrefix = "PIMD_";
+  let clausePrefix = "PIMC_";
+  let makeEnumAvailableInNamespace = true;
+  let enableBitmaskEnumInNamespace = true;
+  let clauseEnumSetClass = "PimClauseSet";
+  let flangClauseBaseClass = "PimClause";
+}
+
+def PIM_Default_none : ClauseVal<"none", 1, 1> { let isDefault = 1; }
+def PIM_Default_present : ClauseVal<"present", 0, 1> {}
+
+def PIMC_Default : Clause<"default"> {
+  let flangClass = "PimDefaultClause";
+  let enumClauseValue = "DefaultValue";
+  let allowedClauseValues = [
+    PIM_Default_present,
+    PIM_Default_none
+  ];
+}
+
+def PIMC_Copy : Clause<"copy"> {
+  let flangClass = "PimObjectList";
+}
+def PIMC_Copyin : Clause<"copyin"> {
+  // let flangClass = "PimObjectListWithModifier";
+  let flangClass = "PimObjectList";
+}
+def PIMC_Copyout : Clause<"copyout"> {
+  // let flangClass = "PimObjectListWithModifier";
+  let flangClass = "PimObjectList";
+}
+
+def PIM_Parallel : Directive<"parallel"> {
+}
+
+def PIM_Loop : Directive<"loop"> {
+}
+
+// def PIM_Libcalls : Directive<"libcalls"> {
+// }
+
+def PIM_ParallelLoop : Directive<"parallel loop"> {
+}
+
+def PIMC_Unknown : Clause<"unknown"> {
+  let isDefault = true;
+}
+
+def PIM_Unknown : Directive<"unknown"> {
+  let isDefault = true;
+}
+
+
+def PIM_RUNTIME_TYPE_Hip : ClauseVal<"hip", 0, 1> {}
+def PIM_RUNTIME_TYPE_Opencl : ClauseVal<"opencl", 1, 1> {}
+def PIM_RUNTIME_TYPE_Default : ClauseVal<"default", 2, 0> { let isDefault = 1; }
+
+def PIMC_RuntimeType : Clause<"runtime_type"> {
+  let enumClauseValue = "RuntimeType";
+  let allowedClauseValues = [
+    PIM_RUNTIME_TYPE_Hip,
+    PIM_RUNTIME_TYPE_Opencl,
+    PIM_RUNTIME_TYPE_Default
+  ];
+}
+
+
+def PIM_PRECISION_TYPE_fp16 : ClauseVal<"fp16", 0, 1> {}
+def PIM_PRECISION_TYPE_int8 : ClauseVal<"int8", 1, 1> {}
+def PIM_PRECISION_TYPE_Default : ClauseVal<"default", 2, 0> { let isDefault = 1; }
+
+def PIMC_PrecisionType : Clause<"precision"> {
+  let enumClauseValue = "Precision";
+  let allowedClauseValues = [
+    PIM_PRECISION_TYPE_fp16,
+    PIM_PRECISION_TYPE_int8,
+    PIM_PRECISION_TYPE_Default
+  ];
+}
+
+def PIM_MEM_TYPE_HOST : ClauseVal<"host", 0, 1> {}
+def PIM_MEM_TYPE_DEVICE : ClauseVal<"device", 1, 1> {}
+def PIM_MEM_TYPE_PIM : ClauseVal<"pim", 2, 1> { let isDefault = 1;}
+
+def PIMC_MemType : Clause<"memtype"> {
+  let enumClauseValue = "Memtype";
+  let allowedClauseValues = [
+    PIM_MEM_TYPE_HOST,
+    PIM_MEM_TYPE_DEVICE,
+    PIM_MEM_TYPE_PIM
+  ];
+}
diff --git a/llvm/include/llvm/Frontend/Pim/PIMIRBuilder.h b/llvm/include/llvm/Frontend/Pim/PIMIRBuilder.h
new file mode 100644
index 000000000000..bfedaaaec30a
--- /dev/null
+++ b/llvm/include/llvm/Frontend/Pim/PIMIRBuilder.h
@@ -0,0 +1,166 @@
+//===- IR/PIMIRBuilder.h - PIM encoding builder for LLVM IR ------- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file defines the PIMIRBuilder class and helpers used as a convenient
+// way to create LLVM instructions for PIM directives.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_FRONTEND_PIM_PIMIRBUILDER_H
+#define LLVM_FRONTEND_PIM_PIMIRBUILDER_H
+
+#include "llvm/ADT/None.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/Twine.h"
+#include "llvm/Frontend/Pim/PIM.h.inc"
+#include "llvm/Analysis/MemorySSAUpdater.h"
+#include "llvm/IR/DebugLoc.h"
+#include "llvm/IR/IRBuilder.h"
+#include "llvm/Support/Allocator.h"
+#include <forward_list>
+
+namespace llvm {
+
+namespace pim {
+enum class RuntimeFunction {
+  __pim_intitialize,
+  __pim_deintitialize,
+
+  __pim_execute_add,
+  __pim_execute_mul,
+
+  __pim_create_bo,
+  __pim_destroy_bo,
+  // __PIM_API__ int PimCopyMemory(void* dst, void* src, size_t size, PimMemCpyType cpy_type);
+  __pim_memcpy,
+  // __PIM_API__ int PimSynchronize(void* stream = nullptr);
+  __pim_sync,
+};
+} // namespace pim
+
+/// An interface to create LLVM-IR for PIM directives.
+///
+/// Each PIM directive has a corresponding public generator method.
+class PIMIRBuilder {
+public:
+  PIMIRBuilder(Module &M) : M{M}, Builder{M.getContext()} {}
+
+  /// The underlying LLVM-IR module
+  Module &M;
+
+  /// The LLVM-IR Builder used to create IR.
+  IRBuilder<> Builder;
+
+
+
+  /// Initialize the internal state, this will put structures types and
+  /// potentially other helpers into the underlying module. Must be called
+  /// before any other method and only once!
+  void initialize();
+
+  /// Finalize the underlying module, e.g., by outlining regions.
+  /// \param Fn                    The function to be finalized. If not used,
+  ///                              all functions are finalized.
+  void finalize(Function *Fn = nullptr);
+
+  /// Return the function declaration for the runtime function with \p FnID.
+  FunctionCallee getOrCreateRuntimeFunction(Module &M,
+                                            pim::RuntimeFunction FnID);
+  Function *getOrCreateRuntimeFunctionPtr(pim::RuntimeFunction FnID);
+
+
+  void generateUnreachableBranch();
+
+  /// Type used throughout for insertion points.
+  using InsertPointTy = IRBuilder<>::InsertPoint;
+  /// Description of a LLVM-IR insertion point (IP) and a debug/source location
+  /// (filename, line, column, ...).
+  struct LocationDescription {
+    LocationDescription(const IRBuilderBase &IRB)
+        : IP(IRB.saveIP()), DL(IRB.getCurrentDebugLocation()) {}
+    LocationDescription(const InsertPointTy &IP) : IP(IP) {}
+    LocationDescription(const InsertPointTy &IP, const DebugLoc &DL)
+        : IP(IP), DL(DL) {}
+    InsertPointTy IP;
+    DebugLoc DL;
+  };
+
+  /// Update the internal location to \p Loc.
+  bool updateToLocation(const LocationDescription &Loc) {
+    Builder.restoreIP(Loc.IP);
+    Builder.SetCurrentDebugLocation(Loc.DL);
+    return Loc.IP.getBlock() != nullptr;
+  }
+
+
+  using FinalizeCallbackTy = std::function<void(InsertPointTy CodeGenIP)>;
+  /// Callback type for body (=inner region) code generation
+  ///
+  /// The callback takes code locations as arguments, each describing a
+  /// location where additional instructions can be inserted.
+  ///
+  /// The CodeGenIP may be in the middle of a basic block or point to the end of
+  /// it. The basic block may have a terminator or be degenerate. The callback
+  /// function may just insert instructions at that position, but also split the
+  /// block (without the Before argument of BasicBlock::splitBasicBlock such
+  /// that the identify of the split predecessor block is preserved) and insert
+  /// additional control flow, including branches that do not lead back to what
+  /// follows the CodeGenIP. Note that since the callback is allowed to split
+  /// the block, callers must assume that InsertPoints to positions in the
+  /// BasicBlock after CodeGenIP including CodeGenIP itself are invalidated. If
+  /// such InsertPoints need to be preserved, it can split the block itself
+  /// before calling the callback.
+  ///
+  /// AllocaIP and CodeGenIP must not point to the same position.
+  ///
+  /// \param AllocaIP is the insertion point at which new alloca instructions
+  ///                 should be placed. The BasicBlock it is pointing to must
+  ///                 not be split.
+  /// \param CodeGenIP is the insertion point at which the body code should be
+  ///                  placed.
+  using BodyGenCallbackTy =
+      function_ref<void(InsertPointTy AllocaIP, InsertPointTy CodeGenIP)>;
+
+  /// Generator for '#pim parallel'
+  ///
+  /// \param Loc The insert and source location description.
+  /// \param AllocaIP The insertion points to be used for alloca instructions.
+  /// \param BodyGenCB Callback that will generate the region code.
+  /// \param PrivCB Callback to copy a given variable (think copy constructor).
+  /// \param FiniCB Callback to finalize variable copies.
+  /// \param IfCondition The evaluated 'if' clause expression, if any.
+  /// \param NumThreads The evaluated 'num_threads' clause expression, if any.
+  /// \param ProcBind The value of the 'proc_bind' clause (see ProcBindKind).
+  /// \param IsCancellable Flag to indicate a cancellable parallel region.
+  ///
+  /// \returns The insertion position *after* the parallel.
+  IRBuilder<>::InsertPoint createParallel(InsertPointTy AllocaIP);
+
+  IRBuilder<>::InsertPoint createAdd(Value* In1, Value *In2, Value *Result);
+
+  // returns the position at the succesefull branch
+  IRBuilder<>::InsertPoint
+  createFunctionReturnGuard(FunctionCallee FC, llvm::StringRef FailMessage,
+                            ArrayRef<Value *> Args = None);
+
+  void insertRuntimeFailNotification(llvm::StringRef Message);
+
+  IRBuilder<>::InsertPoint
+  createYield(const LocationDescription &Loc);
+
+  IRBuilder<>::InsertPoint createBufferObject(Value *N, Value *C, Value *H,
+                                              Value *W, Value *MemType);
+
+  /// Map to remember source location strings
+  StringMap<Constant *> SrcLocStrMap;
+private:
+};
+
+} // end namespace llvm
+
+#endif // LLVM_FRONTEND_PIM_PIMIRBUILDER_H
diff --git a/llvm/include/llvm/Frontend/Pim/PIMOps.td b/llvm/include/llvm/Frontend/Pim/PIMOps.td
new file mode 100644
index 000000000000..1593cd0352f9
--- /dev/null
+++ b/llvm/include/llvm/Frontend/Pim/PIMOps.td
@@ -0,0 +1,51 @@
+#ifndef PIM_OPS
+#define PIM_OPS
+
+include "mlir/IR/DialectBase.td"
+
+// Definition of 'pim' dialect
+def Pim_Dialect : Dialect {
+  let summary = "A short one line description of my dialect.";
+  let description = [{
+    My dialect is a very important dialect. This section contains a much more
+    detailed description that documents all of the important pieces of information
+    to know about the document.
+  }];
+
+  let name = "pim";
+  let cppNamespace = "::pim";
+  let emitAccessorPrefix = kEmitAccessorPrefix_Prefixed;
+
+  // let dependentDialects = [
+  //   "arith::ArithmeticDialect",
+  //   "func::FuncDialect"
+  // ];
+}
+
+// Base class for pim operations.
+class Pim_Op<string mnemonic, list<Trait> traits = []> :
+    Op<Pim_Dialect, mnemonic, traits>;
+
+def AddOp : Pim_Op<"add",
+  [NoSideEffect, DeclareOpInterfaceMethods<ShapeInferenceOpInterface>]> {
+  let summary = "add summary";
+  let description = [{
+    The "add" operation description.
+    Something about operands.
+  }];
+
+  let arguments = (ins PimVar:$lhs, PimVar:$rhs);
+  let results = (outs PimVar);
+
+  // Indicate that the operation has a custom parser and printer method.
+  let hasCustomAssemblyFormat = 1;
+
+  // Allow building an AddOp with from the two input operands.
+  let builders = [
+    OpBuilder<(ins "Value":$lhs, "Value":$rhs)>
+  ];
+
+  // let assemblyFormat = "`<` $count `,` `map` `=` $map `>`";
+}
+
+#endif // PIM_OPS
diff --git a/llvm/lib/Frontend/CMakeLists.txt b/llvm/lib/Frontend/CMakeLists.txt
index ea66917b8936..09ebad6fa23a 100644
--- a/llvm/lib/Frontend/CMakeLists.txt
+++ b/llvm/lib/Frontend/CMakeLists.txt
@@ -1,2 +1,3 @@
 add_subdirectory(OpenACC)
 add_subdirectory(OpenMP)
+add_subdirectory(Pim)
diff --git a/llvm/lib/Frontend/Pim/CMakeLists.txt b/llvm/lib/Frontend/Pim/CMakeLists.txt
new file mode 100644
index 000000000000..bb5ebeef23bd
--- /dev/null
+++ b/llvm/lib/Frontend/Pim/CMakeLists.txt
@@ -0,0 +1,23 @@
+add_llvm_component_library(LLVMFrontendPIM
+  PIM.cpp
+  PIMIRBuilder.cpp
+
+  ADDITIONAL_HEADER_DIRS
+  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Frontend
+  ${LLVM_MAIN_INCLUDE_DIR}/llvm/Frontend/Pim
+
+  DEPENDS
+  intrinsics_gen
+  pim_gen
+
+  LINK_COMPONENTS
+  Core
+  Support
+  TransformUtils
+  Analysis
+  MC
+  Scalar
+  )
+
+# target_link_libraries(LLVMFrontendPIM LLVMSupport)
+
diff --git a/llvm/lib/Frontend/Pim/PIM.cpp b/llvm/lib/Frontend/Pim/PIM.cpp
new file mode 100644
index 000000000000..2db99c9dab7e
--- /dev/null
+++ b/llvm/lib/Frontend/Pim/PIM.cpp
@@ -0,0 +1,19 @@
+//===- PIM.cpp ------ Collection of helpers for PIM -----------------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "llvm/Frontend/Pim/PIM.h.inc"
+
+#include "llvm/ADT/StringRef.h"
+#include "llvm/ADT/StringSwitch.h"
+#include "llvm/Support/ErrorHandling.h"
+
+using namespace llvm;
+using namespace pim;
+
+#define GEN_DIRECTIVES_IMPL
+#include "llvm/Frontend/Pim/PIM.inc"
diff --git a/llvm/lib/Frontend/Pim/PIMIRBuilder.cpp b/llvm/lib/Frontend/Pim/PIMIRBuilder.cpp
new file mode 100644
index 000000000000..e143fbf01475
--- /dev/null
+++ b/llvm/lib/Frontend/Pim/PIMIRBuilder.cpp
@@ -0,0 +1,392 @@
+//===- PimIRBuilder.cpp - Builder for LLVM-IR for Pim directives ----===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+/// \file
+///
+/// This file implements the PimIRBuilder class, which is used as a
+/// convenient way to create LLVM instructions for Pim directives.
+///
+//===----------------------------------------------------------------------===//
+
+#include "llvm/Frontend/Pim/PIMIRBuilder.h"
+#include "llvm/ADT/None.h"
+#include "llvm/ADT/SmallSet.h"
+#include "llvm/ADT/StringRef.h"
+#include "llvm/Analysis/AssumptionCache.h"
+#include "llvm/Analysis/CodeMetrics.h"
+#include "llvm/Analysis/LoopInfo.h"
+#include "llvm/Analysis/OptimizationRemarkEmitter.h"
+#include "llvm/Analysis/ScalarEvolution.h"
+#include "llvm/Analysis/TargetLibraryInfo.h"
+#include "llvm/Frontend/Pim/PIM.h.inc"
+#include "llvm/IR/Attributes.h"
+#include "llvm/IR/BasicBlock.h"
+#include "llvm/IR/CFG.h"
+#include "llvm/IR/Constant.h"
+#include "llvm/IR/Constants.h"
+#include "llvm/IR/DebugInfoMetadata.h"
+#include "llvm/IR/DerivedTypes.h"
+#include "llvm/IR/Function.h"
+#include "llvm/IR/GlobalValue.h"
+#include "llvm/IR/GlobalVariable.h"
+#include "llvm/IR/IRBuilder.h"
+#include "llvm/IR/MDBuilder.h"
+#include "llvm/IR/Module.h"
+#include "llvm/IR/PassManager.h"
+#include "llvm/IR/Value.h"
+#include "llvm/MC/TargetRegistry.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Target/TargetMachine.h"
+#include "llvm/Target/TargetOptions.h"
+#include "llvm/Transforms/Utils/BasicBlockUtils.h"
+#include "llvm/Transforms/Utils/Cloning.h"
+#include "llvm/Transforms/Utils/CodeExtractor.h"
+#include "llvm/Transforms/Utils/LoopPeel.h"
+#include "llvm/Transforms/Utils/UnrollLoop.h"
+
+#include <cstdint>
+
+#define DEBUG_TYPE "pim-ir-builder"
+
+using namespace llvm;
+using namespace pim;
+
+
+// typedef struct __PimBufferShape {
+//     uint32_t n;
+//     uint32_t c;
+//     uint32_t h;
+//     uint32_t w;
+// } PimBShape;
+
+// typedef struct __PimBufferObject {
+//     PimMemType mem_type;
+//     PimBShape bshape;
+//     PimBShape bshape_r;
+//     PimPrecision precision;
+//     size_t size;
+//     void *data;
+//     bool use_user_ptr;
+// } PimBo;
+
+
+FunctionCallee
+PIMIRBuilder::getOrCreateRuntimeFunction(Module &M, pim::RuntimeFunction FnID) {
+  FunctionType *FnTy = nullptr;
+  Function *Fn = nullptr;
+
+  IRBuilder<> IRB(M.getContext());
+  // Try to find the declation in the module first.
+  switch (FnID) {
+  case pim::RuntimeFunction::__pim_intitialize:
+    // __PIM_API__ int PimInitialize(PimRuntimeType rt_type = RT_TYPE_HIP,
+    // PimPrecision = PIM_FP16);
+    FnTy = FunctionType::get(
+        IRB.getInt32Ty(), ArrayRef<Type *>{IRB.getInt32Ty(), IRB.getInt32Ty()},
+        /*IsVarArg=*/false);
+    Fn = M.getFunction("PimInitialize");
+    break;
+  case pim::RuntimeFunction::__pim_deintitialize:
+    FnTy = FunctionType::get(IRB.getInt32Ty(), /*IsVarArg=*/false);
+    Fn = M.getFunction("PimDeinitialize");
+    break;
+  case pim::RuntimeFunction::__pim_execute_add:
+    FnTy = FunctionType::get(
+        IRB.getInt32Ty(),
+        ArrayRef<Type *>{
+            IRB.getPtrTy() /*output*/, IRB.getPtrTy() /* op0 */,
+            IRB.getPtrTy() /* op1 */, IRB.getPtrTy() /* stream */,
+            IRB.getInt1Ty() /* block */
+        },
+        /*IsVarArg=*/false);
+    Fn = M.getFunction("PimExecuteAdd");
+    break;
+  case pim::RuntimeFunction::__pim_sync:
+    FnTy = FunctionType::get(IRB.getInt32Ty(),
+                             ArrayRef<Type *>{IRB.getPtrTy() /*stream*/},
+
+                             /*IsVarArg=*/false);
+    Fn = M.getFunction("PimSynchronize");
+    break;
+  case pim::RuntimeFunction::__pim_memcpy:
+
+    FnTy = FunctionType::get(IRB.getInt32Ty(),
+                             ArrayRef<Type *>{
+                                 IRB.getPtrTy() /*dst*/, IRB.getPtrTy() /*src*/,
+                                 IRB.getInt32Ty(), // size
+                                 IRB.getInt32Ty()  // PimMemCpyType
+                             },
+                             /*IsVarArg=*/false);
+
+    Fn = M.getFunction("PimCopyMemory");
+    break;
+  }
+
+  if (!Fn) {
+    // Create a new declaration if we need one.
+    switch (FnID) {
+    case pim::RuntimeFunction::__pim_intitialize:
+      Fn = Function::Create(FnTy, GlobalValue::ExternalLinkage, "PimInitialize",
+                            M);
+      Fn->setCallingConv(CallingConv::C);
+      break;
+    case pim::RuntimeFunction::__pim_deintitialize:
+      Fn = Function::Create(FnTy, GlobalValue::ExternalLinkage,
+                            "PimDeinitialize", M);
+      Fn->setCallingConv(CallingConv::C);
+      break;
+    case pim::RuntimeFunction::__pim_execute_add:
+      Fn = Function::Create(FnTy, GlobalValue::ExternalLinkage, "PimExecuteAdd",
+                            M);
+      Fn->setCallingConv(CallingConv::C);
+
+    }
+
+    LLVM_DEBUG(dbgs() << "Created PIM runtime function '" << Fn->getName()
+                      << "' with type '" << *Fn->getFunctionType() << "'\n");
+
+    Fn->addFnAttr(Attribute::WillReturn);
+    Fn->addFnAttr(Attribute::NoUnwind);
+    Fn->addFnAttr(Attribute::NoSync);
+
+    // TODO(mike): add attributes:
+    //                 ? AttributeSet(EnumAttr(NoUnwind), EnumAttr(WriteOnly),
+    //                                EnumAttr(NoSync), EnumAttr(NoFree),
+    //                                EnumAttr(InaccessibleMemOnly),
+    //                                EnumAttr(WillReturn))
+    //                 : AttributeSet(EnumAttr(NoUnwind)))
+    // addAttributes(FnID, *Fn);
+
+  } else {
+    LLVM_DEBUG(dbgs() << "Found PIM runtime function " << Fn->getName()
+                      << " with type " << *Fn->getFunctionType() << "\n");
+  }
+
+  assert(Fn && "Failed to create PIM runtime function");
+
+  // Cast the function to the expected type if necessary
+  Constant *C = ConstantExpr::getBitCast(Fn, FnTy->getPointerTo());
+  return {FnTy, C};
+}
+
+Function *PIMIRBuilder::getOrCreateRuntimeFunctionPtr(RuntimeFunction FnID) {
+  FunctionCallee RTLFn = getOrCreateRuntimeFunction(M, FnID);
+  auto *Fn = dyn_cast<llvm::Function>(RTLFn.getCallee());
+  assert(Fn && "Failed to create PIM runtime function pointer");
+  return Fn;
+}
+
+
+void PIMIRBuilder::initialize() {  }
+
+void PIMIRBuilder::finalize(Function *) {}
+
+IRBuilder<>::InsertPoint PIMIRBuilder::createFunctionReturnGuard(
+    FunctionCallee FC, llvm::StringRef FailMessage, ArrayRef<Value *> Args) {
+  BasicBlock *BB = Builder.GetInsertBlock();
+  BasicBlock *SuccessBB = BasicBlock::Create(
+      M.getContext(),
+      BB->getName() + "." + FC.getCallee()->getName() + ".success",
+      BB->getParent());
+  BasicBlock *FailBB = BasicBlock::Create(
+      M.getContext(), BB->getName() + "." + FC.getCallee()->getName() + ".fail",
+      BB->getParent());
+  // Value* Result = Builder.CreateCall(FC, Args);
+  // Builder.CreateCall(getOrCreateRuntimeFunction(M,
+  // RuntimeFunction::__pim_deintitialize));
+  Value *Result = Builder.CreateCall(FC, Args);
+  Value *CallBoolResult = Builder.CreateIsNotNull(Result);
+  Builder.CreateCondBr(CallBoolResult, SuccessBB, FailBB);
+  Builder.SetInsertPoint(FailBB);
+  insertRuntimeFailNotification(FailMessage);
+  Builder.SetInsertPoint(SuccessBB);
+  return Builder.saveIP();
+}
+
+void PIMIRBuilder::insertRuntimeFailNotification(llvm::StringRef Message) {
+  (void)Message;
+  // TODO: print message in runtime
+  FunctionCallee CalleeF = M.getOrInsertFunction(
+      "printf",
+      FunctionType::get(IntegerType::getInt32Ty(M.getContext()),
+                        PointerType::get(Type::getInt8Ty(M.getContext()), 0),
+                        true /* this is var arg func type*/));
+  Value *PrintFormat = Builder.CreateGlobalString("%s\n");
+  Value *PrintMessage = Builder.CreateGlobalString(Message);
+  Builder.CreateCall(CalleeF, {PrintFormat, PrintMessage});
+  // Terminate fail block
+  Builder.CreateUnreachable();
+}
+
+IRBuilder<>::InsertPoint
+PIMIRBuilder::createParallel(InsertPointTy AllocaIP) {
+  LLVM_DEBUG(dbgs() << "PIM  createParallel" << "\n");
+  // Function* Fn = getOrCreateRuntimeFunctionPtr(RuntimeFunction::__pim_intitialize);
+  LLVM_DEBUG(dbgs() << "PIM created runtime fn call\n");
+  // BasicBlock *Old = Builder.GetInsertBlock();
+  // Builder.SetInsertPoint(Old);
+
+  // BasicBlock *Old = Builder.GetInsertBlock();
+  // BasicBlock *BB = BasicBlock::Create(M.getContext(), ".pim_init", Old->getParent());
+  // LLVM_DEBUG(dbgs() << "PIM set bb for call\n");
+  // auto *CI = CallInst::Create(Fn, nullptr, "", BB);
+  // CI->setTailCallKind(CallInst::TCK_MustTail);
+  
+  // BasicBlock *BB = Builder.GetInsertBlock();
+  // BasicBlock *InitBB;
+
+  // InitBB = SplitBlock(BB, &*Builder.GetInsertPoint());
+  // BB->getTerminator()->eraseFromParent();
+  // TODO: handle else branch
+  // Builder.SetInsertPoint()
+  // Builder.SetInsertPoint(InitBB);
+
+  // BasicBlock *Parent = Builder.GetInsertBlock();
+
+  LLVM_DEBUG(dbgs() << "PIM before CreateCall\n");
+  // Builder.CreateCall(Fn);
+
+  // InsertPointTy PreInitIP = Builder.saveIP();
+  // BasicBlock *InitBB = BasicBlock::Create(M.getContext(), "pim_init");
+  // Builder.SetInsertPoint(InitBB);
+  // Builder.CreateCall(getOrCreateRuntimeFunction(M, RuntimeFunction::__pim_intitialize));
+  LLVM_DEBUG(dbgs() << "PIM after CreateCall\n");
+  // Builder.SetInsertPoint(PreInitIP);
+
+  Builder.restoreIP(AllocaIP);
+  LLVM_DEBUG(dbgs() << "PIM return from parallel generation\n");
+  // return Builder.saveIP();
+  BasicBlock *BB = Builder.GetInsertBlock();
+  BasicBlock *InitBB = BasicBlock::Create(M.getContext(), BB->getName() + "pim.init", BB->getParent());
+  Builder.CreateBr(InitBB);
+  Builder.SetInsertPoint(InitBB);
+
+  Value *RuntimeType = ConstantInt::get(
+      Type::getInt32Ty(M.getContext()),
+      static_cast<int>(llvm::pim::RuntimeType::PIM_RUNTIME_TYPE_Hip));
+  Value *PrecisionType = ConstantInt::get(
+      Type::getInt32Ty(M.getContext()),
+      static_cast<int>(llvm::pim::Precision::PIM_PRECISION_TYPE_fp16));
+
+  Value *InitArgs[] = {RuntimeType, PrecisionType};
+
+  Type *I32Type = Type::getInt32Ty(M.getContext());
+  Value *Idx = Builder.CreateAlloca(I32Type, nullptr, "upper.bound");
+  Constant* One = ConstantInt::get(Type::getInt32Ty(M.getContext()), 1);
+  Builder.CreateStore(One, Idx);
+  // Builder.CreateUnreachable();
+  // Builder.CreateInvoke()
+  // Builder.CreateCallBr();
+
+  // Builder.CreateCall(getOrCreateRuntimeFunction(M, RuntimeFunction::__pim_intitialize), InitArgs);
+  createFunctionReturnGuard(
+      getOrCreateRuntimeFunctionPtr(RuntimeFunction::__pim_intitialize),
+      "Failed to call pim initialization",
+      InitArgs);
+  // Instruction* Branch = &BB->back();
+  // auto *BI = cast<BranchInst>(Branch);
+
+
+  BasicBlock *BodyBB = BasicBlock::Create(M.getContext(), BB->getName() + "pim.body", BB->getParent());
+
+
+  Builder.CreateBr(BodyBB);
+  Builder.SetInsertPoint(BodyBB);
+
+  Value* Input1 = Builder.CreateAlloca(Type::getInt32PtrTy(M.getContext()), nullptr, "input1");
+  Value* Input2 = Builder.CreateAlloca(Type::getInt32PtrTy(M.getContext()), nullptr, "input2");
+  Value* Result = Builder.CreateAlloca(Type::getInt32PtrTy(M.getContext()), nullptr, "result");
+  createAdd(Input1, Input2, Result);
+  // Value* Result = Builder.CreateCall(getOrCreateRuntimeFunction(M, RuntimeFunction::__pim_execute_add), Args);
+
+  // __PIM_API__ int PimExecuteAdd(PimBo* output,
+  //                               void* scalar,
+  //                               PimBo* vector,
+  //                               void* stream = nullptr, bool block = false);
+
+  // LLVM_DEBUG(dbgs() << "pim body: "
+  //            << *Builder.GetInsertBlock()->getParent() << "\n");
+
+  BasicBlock *DeinitBB = BasicBlock::Create(M.getContext(), BB->getName() + "pim.deinit", BB->getParent());
+  Builder.CreateBr(DeinitBB);
+  Builder.SetInsertPoint(DeinitBB);
+
+  createFunctionReturnGuard(
+      getOrCreateRuntimeFunctionPtr(RuntimeFunction::__pim_deintitialize),
+      "Failed to call pim deinitialization");
+
+  // Builder.CreateCall(getOrCreateRuntimeFunctionPtr(RuntimeFunction::__pim_deintitialize));
+
+  return Builder.saveIP();
+
+  // Builder.SetInsertPoint(BB);
+
+// Basic Block in function 'test_parallel' does not have terminator!
+
+// something you did might
+// have promoted it to an Instruction but not put it into any basic block
+// but I can't think of anything right now.
+
+// PIM  createParallel: 
+// Created PIM runtime function 'pim_intitialize' with type 'void ()'
+// PIM created runtime fn call
+// Global is referenced by parentless instruction!
+// ptr @pim_intitialize
+// ; ModuleID = 'LLVMDialectModule'
+//   call addrspace(0) void @pim_intitialize()
+// While deleting: ptr %pim_intitialize
+// Use still stuck around after Def is destroyed:  call addrspace(0) void @pim_intitialize()
+  // return AllocaIP;
+}
+
+
+IRBuilder<>::InsertPoint PIMIRBuilder::createAdd(Value* In1, Value *In2, Value *Result) {
+  IRBuilder<> IRB(M.getContext());
+  auto *Int32PtrTy = Type::getInt32PtrTy(M.getContext());
+  Constant *StreamVal = ConstantPointerNull::get(Int32PtrTy);
+  Constant* BlockVal = ConstantInt::getBool(M.getContext(), false);
+
+  Value *Args[] = {Result, In1, In2, StreamVal, BlockVal};
+  createFunctionReturnGuard(
+      getOrCreateRuntimeFunctionPtr(RuntimeFunction::__pim_execute_add),
+      "Failed to call pim execute add", Args);
+  createBufferObject(nullptr, nullptr, nullptr, nullptr, nullptr);
+  return Builder.saveIP();
+}
+
+IRBuilder<>::InsertPoint PIMIRBuilder::createBufferObject(Value* N, Value *C, Value *H, Value* W, Value* MemType) {
+  // StructType* BufferObjectType = StructType::create(M.getContext(), "buffer.obj");
+// typedef struct __PimBufferShape {
+//     uint32_t n;
+//     uint32_t c;
+//     uint32_t h;
+//     uint32_t w;
+// } PimBShape;
+
+
+  // Type* BufferShapeFieldTypes[] = {
+  //   Builder.getInt32Ty()
+  // };
+  StructType *BufferShapeStruct = StructType::create(
+      M.getContext(), {Builder.getInt32Ty(), Builder.getInt32Ty()}, "b.shape");
+
+  Constant* Cnst = ConstantStruct::get(BufferShapeStruct,
+                      {Builder.getInt32(10),
+                       Builder.getInt32(30)});
+  // AllocaInst *SomeAlloca = Builder.CreateAlloca(BufferShapeStruct, Cnst, "some.shape");
+  // SomeAlloca->getAllocatedType()->get
+  return Builder.saveIP();
+}
+
+
+
+IRBuilder<>::InsertPoint
+PIMIRBuilder::createYield(const LocationDescription &Loc) {
+  LLVM_DEBUG(dbgs() << "PIM createYield\n");
+  assert(false);
+  return Builder.saveIP();
+}
diff --git a/mlir/include/mlir/Conversion/Passes.h b/mlir/include/mlir/Conversion/Passes.h
index 9f10e9459f45..32ff1249b26e 100644
--- a/mlir/include/mlir/Conversion/Passes.h
+++ b/mlir/include/mlir/Conversion/Passes.h
@@ -41,6 +41,7 @@
 #include "mlir/Conversion/OpenACCToLLVM/ConvertOpenACCToLLVM.h"
 #include "mlir/Conversion/OpenACCToSCF/ConvertOpenACCToSCF.h"
 #include "mlir/Conversion/OpenMPToLLVM/ConvertOpenMPToLLVM.h"
+#include "mlir/Conversion/PimToLLVM/ConvertPimToLLVM.h"
 #include "mlir/Conversion/PDLToPDLInterp/PDLToPDLInterp.h"
 #include "mlir/Conversion/ReconcileUnrealizedCasts/ReconcileUnrealizedCasts.h"
 #include "mlir/Conversion/SCFToControlFlow/SCFToControlFlow.h"
diff --git a/mlir/include/mlir/Conversion/Passes.td b/mlir/include/mlir/Conversion/Passes.td
index bacbaeb511c8..c85335f86807 100644
--- a/mlir/include/mlir/Conversion/Passes.td
+++ b/mlir/include/mlir/Conversion/Passes.td
@@ -605,6 +605,16 @@ def ConvertOpenMPToLLVM : Pass<"convert-openmp-to-llvm", "ModuleOp"> {
   let dependentDialects = ["LLVM::LLVMDialect"];
 }
 
+//===----------------------------------------------------------------------===//
+// PIMToLLVM
+//===----------------------------------------------------------------------===//
+
+def ConvertPimToLLVM : Pass<"convert-pim-to-llvm", "ModuleOp"> {
+  let summary = "Convert the PIM ops to PIM ops with LLVM dialect";
+  let constructor = "mlir::createConvertPimToLLVMPass()";
+  let dependentDialects = ["LLVM::LLVMDialect"];
+}
+
 //===----------------------------------------------------------------------===//
 // PDLToPDLInterp
 //===----------------------------------------------------------------------===//
diff --git a/mlir/include/mlir/Conversion/PimToLLVM/ConvertPimToLLVM.h b/mlir/include/mlir/Conversion/PimToLLVM/ConvertPimToLLVM.h
new file mode 100644
index 000000000000..f26dd5387d90
--- /dev/null
+++ b/mlir/include/mlir/Conversion/PimToLLVM/ConvertPimToLLVM.h
@@ -0,0 +1,33 @@
+//===- PimToLLVM.h - Utils to convert from the Pim dialect ----------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+#ifndef MLIR_CONVERSION_PIMTOLLVM_CONVERTPIMTOLLVM_H
+#define MLIR_CONVERSION_PIMTOLLVM_CONVERTPIMTOLLVM_H
+
+#include <memory>
+
+namespace mlir {
+class LLVMTypeConverter;
+class ConversionTarget;
+class MLIRContext;
+class ModuleOp;
+template <typename T>
+class OperationPass;
+class RewritePatternSet;
+
+
+/// Populate the given list with patterns that convert from Pim to LLVM.
+void populatePimToLLVMConversionPatterns(LLVMTypeConverter &converter,
+                                         RewritePatternSet &patterns);
+
+/// Create a pass to convert Pim operations to the LLVMIR dialect.
+std::unique_ptr<OperationPass<ModuleOp>> createConvertPimToLLVMPass();
+
+} // namespace mlir
+
+
+#endif // MLIR_CONVERSION_PIMTOLLVM_CONVERTPIMTOLLVM_H
diff --git a/mlir/include/mlir/Dialect/CMakeLists.txt b/mlir/include/mlir/Dialect/CMakeLists.txt
index 270cd54cca96..8b1fe3305a60 100644
--- a/mlir/include/mlir/Dialect/CMakeLists.txt
+++ b/mlir/include/mlir/Dialect/CMakeLists.txt
@@ -20,6 +20,7 @@ add_subdirectory(MLProgram)
 add_subdirectory(NVGPU)
 add_subdirectory(OpenACC)
 add_subdirectory(OpenMP)
+add_subdirectory(Pim)
 add_subdirectory(PDL)
 add_subdirectory(PDLInterp)
 add_subdirectory(Quant)
diff --git a/mlir/include/mlir/Dialect/Pim/CMakeLists.txt b/mlir/include/mlir/Dialect/Pim/CMakeLists.txt
new file mode 100644
index 000000000000..0fe704e628e3
--- /dev/null
+++ b/mlir/include/mlir/Dialect/Pim/CMakeLists.txt
@@ -0,0 +1,47 @@
+# set(LLVM_TARGET_DEFINITIONS ${LLVM_MAIN_INCLUDE_DIR}/llvm/Frontend/Pim/PIM.td)
+# mlir_tablegen(PimCommon.td --gen-directive-decl --directives-dialect=Pim)
+# add_public_tablegen_target(pim_common_td)
+
+# set(LLVM_TARGET_DEFINITIONS PimOps.td)
+# mlir_tablegen(PimOpsDialect.h.inc -gen-dialect-decls -dialect=pim)
+# mlir_tablegen(PimOpsDialect.cpp.inc -gen-dialect-defs -dialect=pim)
+# mlir_tablegen(PimOps.h.inc -gen-op-decls)
+# mlir_tablegen(PimOps.cpp.inc -gen-op-defs)
+# mlir_tablegen(PimOpsEnums.h.inc -gen-enum-decls)
+# mlir_tablegen(PimOpsEnums.cpp.inc -gen-enum-defs)
+# mlir_tablegen(PimOpsAttributes.h.inc -gen-attrdef-decls -attrdefs-dialect=pim)
+# mlir_tablegen(PimOpsAttributes.cpp.inc -gen-attrdef-defs -attrdefs-dialect=pim)
+# add_mlir_doc(PimOps PimDialect Dialects/ -gen-dialect-doc)
+# add_public_tablegen_target(MLIRPimOpsIncGen)
+# add_dependencies(PimDialectDocGen pim_common_td)
+# add_mlir_interface(PimOpsInterfaces)
+
+
+# set(LLVM_TARGET_DEFINITIONS PimOps.td)
+# mlir_tablegen(PimTypeInterfaces.h.inc -gen-type-interface-decls)
+# mlir_tablegen(PimTypeInterfaces.cpp.inc -gen-type-interface-defs)
+# add_public_tablegen_target(MLIRPimTypeInterfacesIncGen)
+# add_dependencies(mlir-generic-headers MLIRPimTypeInterfacesIncGen)
+
+
+
+
+
+set(LLVM_TARGET_DEFINITIONS ${LLVM_MAIN_INCLUDE_DIR}/llvm/Frontend/Pim/PIM.td)
+mlir_tablegen(PimCommon.td --gen-directive-decl --directives-dialect=Pim)
+add_public_tablegen_target(pim_common_td)
+
+set(LLVM_TARGET_DEFINITIONS PimOps.td)
+mlir_tablegen(PimOpsDialect.h.inc -gen-dialect-decls -dialect=pim)
+mlir_tablegen(PimOpsDialect.cpp.inc -gen-dialect-defs -dialect=pim)
+mlir_tablegen(PimOps.h.inc -gen-op-decls)
+mlir_tablegen(PimOps.cpp.inc -gen-op-defs)
+mlir_tablegen(PimOpsEnums.h.inc -gen-enum-decls)
+mlir_tablegen(PimOpsEnums.cpp.inc -gen-enum-defs)
+mlir_tablegen(PimOpsAttributes.h.inc -gen-attrdef-decls -attrdefs-dialect=pim)
+mlir_tablegen(PimOpsAttributes.cpp.inc -gen-attrdef-defs -attrdefs-dialect=pim)
+mlir_tablegen(PimOpsTypes.h.inc --gen-typedef-decls)
+mlir_tablegen(PimOpsTypes.cpp.inc --gen-typedef-defs)
+add_mlir_doc(PimOps PimDialect Dialects/ -gen-dialect-doc)
+add_public_tablegen_target(MLIRPimOpsIncGen)
+add_dependencies(PimDialectDocGen pim_common_td)
diff --git a/mlir/include/mlir/Dialect/Pim/Pim.h b/mlir/include/mlir/Dialect/Pim/Pim.h
new file mode 100644
index 000000000000..a6fd98c42b43
--- /dev/null
+++ b/mlir/include/mlir/Dialect/Pim/Pim.h
@@ -0,0 +1,52 @@
+//===- Pim.h - MLIR Pim Dialect -------------------------*- C++ -*-===//
+//
+// Part of the MLIR Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+// ============================================================================
+//
+// This file declares the Pim dialect in MLIR.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef MLIR_DIALECT_PIM_PIM_H_
+#define MLIR_DIALECT_PIM_PIM_H_
+
+#include "mlir/IR/Dialect.h"
+#include "mlir/IR/BuiltinTypes.h"
+#include "mlir/IR/OpDefinition.h"
+#include "mlir/Interfaces/InferTypeOpInterface.h"
+#include "mlir/Interfaces/SideEffectInterfaces.h"
+
+#define GET_TYPEDEF_CLASSES
+#include "mlir/Dialect/Pim/PimOpsTypes.h.inc"
+
+#include "mlir/Dialect/Pim/PimOpsDialect.h.inc"
+#include "mlir/Dialect/Pim/PimOpsEnums.h.inc"
+
+#define GET_ATTRDEF_CLASSES
+#include "mlir/Dialect/Pim/PimOpsAttributes.h.inc"
+
+#define GET_OP_CLASSES
+#include "mlir/Dialect/Pim/PimOps.h.inc"
+
+
+namespace mlir {
+namespace pim {
+
+/// Enumeration used to encode the execution mapping on a loop construct.
+/// They refer directly to the Pim 3.1 standard:
+/// 2.9.2. gang
+/// 2.9.3. worker
+/// 2.9.4. vector
+///
+/// Value can be combined bitwise to reflect the mapping applied to the
+/// construct. e.g. `pim.loop gang vector`, the `gang` and `vector` could be
+/// combined and the final mapping value would be 5 (4 | 1).
+enum PimExecMapping { NONE = 0, VECTOR = 1, WORKER = 2, GANG = 4 };
+
+} // namespace pim
+} // namespace mlir
+
+#endif // MLIR_DIALECT_PIM_PIM_H_
diff --git a/mlir/include/mlir/Dialect/Pim/PimDialect.h b/mlir/include/mlir/Dialect/Pim/PimDialect.h
new file mode 100644
index 000000000000..ed15f5ecb530
--- /dev/null
+++ b/mlir/include/mlir/Dialect/Pim/PimDialect.h
@@ -0,0 +1,35 @@
+//===- PimDialect.h - MLIR Dialect for Pim ----------------------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file declares the Pim dialect in MLIR.
+//
+//===----------------------------------------------------------------------===//
+
+#pragma once
+
+#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
+#include "mlir/IR/Dialect.h"
+#include "mlir/IR/OpDefinition.h"
+#include "mlir/IR/SymbolTable.h"
+#include "mlir/Interfaces/ControlFlowInterfaces.h"
+#include "mlir/Interfaces/SideEffectInterfaces.h"
+
+
+#define GET_TYPEDEF_CLASSES
+#include "mlir/Dialect/Pim/PimOpsTypes.h.inc"
+
+#include "mlir/Dialect/Pim/PimOpsDialect.h.inc"
+#include "mlir/Dialect/Pim/PimOpsEnums.h.inc"
+// #include "mlir/Dialect/Pim/PimOpsInterfaces.h.inc"
+// #include "mlir/Dialect/Pim/PimTypeInterfaces.h.inc"
+
+#define GET_ATTRDEF_CLASSES
+#include "mlir/Dialect/Pim/PimOpsAttributes.h.inc"
+
+#define GET_OP_CLASSES
+#include "mlir/Dialect/Pim/PimOps.h.inc"
diff --git a/mlir/include/mlir/Dialect/Pim/PimOps.td b/mlir/include/mlir/Dialect/Pim/PimOps.td
new file mode 100644
index 000000000000..167710d39c47
--- /dev/null
+++ b/mlir/include/mlir/Dialect/Pim/PimOps.td
@@ -0,0 +1,287 @@
+//===- Pim.td - Pim operation definitions ------_-----------*- tablegen -*-===//
+//
+// Part of the MLIR Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+// =============================================================================
+//
+// Defines MLIR Pim operations.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef PIM_OPS
+#define PIM_OPS
+
+include "mlir/IR/EnumAttr.td"
+include "mlir/IR/OpBase.td"
+include "mlir/Interfaces/InferTypeOpInterface.td"
+include "mlir/Interfaces/SideEffectInterfaces.td"
+include "mlir/IR/AttrTypeBase.td"
+
+def Pim_Dialect : Dialect {
+  let name = "pim";
+  let summary = "Pim dialect for MLIR.";
+  let description = [{
+    This dialect models the construct from the Pim directive language.
+  }];
+  let useDefaultAttributePrinterParser = 1;
+  let useDefaultTypePrinterParser = 1;
+  let cppNamespace = "::mlir::pim";
+  // TODO: Flip to _Prefixed.
+  let emitAccessorPrefix = kEmitAccessorPrefix_Raw;
+}
+
+// PimCommon requires definition of PIM_Dialect.
+include "mlir/Dialect/Pim/PimCommon.td"
+
+// Base class for Pim dialect ops.
+class Pim_Op<string mnemonic, list<Trait> traits = []> :
+  Op<Pim_Dialect, mnemonic, traits>;
+
+
+class Pim_Type<string name, string typeMnemonic> : TypeDef<Pim_Dialect, name> {
+  let mnemonic = typeMnemonic;
+}
+
+class Pim_Attr<string name, string attrMnemonic, list<Trait> traits = []>
+    : AttrDef<Pim_Dialect, name, traits> {
+  let mnemonic = attrMnemonic;
+}
+
+def PimMemTypeHOST: I32EnumAttrCase<"HOST", 1>;
+def PimMemTypeDEVICE: I32EnumAttrCase<"DEVICE", 2>;
+def PimMemTypePIM: I32EnumAttrCase<"PIM", 3>;
+
+def PimMemType : I32EnumAttr<
+    "MemType",
+    "pim.buffer memory type",
+    [PimMemTypeHOST, PimMemTypeDEVICE, PimMemTypePIM]> {
+  let cppNamespace = "::mlir::pim";
+}
+
+// def Pim_MemType: I32EnumAttr<"MemoryType", "Pim memory type",
+//                            [MEM_TYPE_HOST, MEM_TYPE_DEVICE, MEM_TYPE_PIM]> {
+//   let cppNamespace = "pim";
+//   let stringToSymbolFnName = "ConvertToEnum";
+//   let symbolToStringFnName = "ConvertToString";
+// }
+
+
+
+def Pim_BufferType : Pim_Type<"Buffer", "buffer"> {
+  let summary = "Pim device buffer type descriptor.";
+  let parameters = (ins "mlir::Type":$eleTy);
+  // let genAccessors = 1;
+  let assemblyFormat = "`buffer` `<` $eleTy `>`";
+  // let genVerifyDecl = 1;
+}
+
+
+// Yield operation for the acc.loop and acc.parallel operations.
+def Pim_YieldOp : Pim_Op<"yield", [Terminator,
+    ParentOneOf<["ParallelOp"]>]> {
+  let summary = "Pim yield and termination operation";
+
+  let description = [{
+    `pim.yield` is a special terminator operation for block inside regions in
+    pim ops (parallel and loop). It returns values to the immediately enclosing
+    pim op.
+  }];
+
+  let arguments = (ins Variadic<AnyType>:$operands);
+
+  let builders = [OpBuilder<(ins), [{ /* nothing to do */ }]>];
+
+  let assemblyFormat = "attr-dict ($operands^ `:` type($operands))?";
+}
+
+def Pim_SumOp : Pim_Op<"sum", [NoSideEffect,
+  SameOperandsAndResultType, Commutative]> {
+  let summary = "Sum op";
+  let description = [{
+    `pim.sum` op
+  }];
+  let arguments = (ins F<16>:$lhs, F<16>:$rhs);
+  let results = (outs F<16>:$result);
+  let assemblyFormat = "$lhs `,` $rhs  attr-dict `:` type($result)";
+}
+
+def Pim_MulOp : Pim_Op<"mul", [NoSideEffect,
+  SameOperandsAndResultType, Commutative]> {
+  let summary = "Mul op";
+  let description = [{
+    `pim.mul` op
+  }];
+  let arguments = (ins F<16>:$lhs, F<16>:$rhs);
+  let results = (outs F<16>:$result);
+  let assemblyFormat = "$lhs `,` $rhs  attr-dict `:` type($result)";
+}
+
+def Pim_CreateBoOp : Pim_Op<"create_bo", [NoSideEffect]> {
+  let summary = "Create Pim buffer object";
+  // TODO:
+  let arguments = (ins AnyInteger:$n,
+                       AnyInteger:$c,
+                       AnyInteger:$h,
+                       AnyInteger:$w,
+                       AnyInteger:$mem_type);
+  let results = (outs Arg<AnyMemRef, "bo object", [MemWrite]>:$result);
+}
+
+def Pim_DestroyBoOp : Pim_Op<"destroy_bo", [NoSideEffect]> {
+  let summary = "Destroy Pim buffer object";
+  // TODO:
+  let arguments = (ins Arg<AnyMemRef, "bo object", [MemWrite]>:$input);
+}
+
+def Pim_CopyMemoryOp : Pim_Op<"memcpy", [NoSideEffect]> {
+  let arguments = (ins Arg<AnyMemRef, "bo object", [MemWrite]>:$input);
+
+  let arguments = (ins Arg<AnyMemRef, "", [MemWrite]>:$dst,
+                       Arg<AnyMemRef, "", [MemRead]>:$src,
+                       AnyInteger:$direction);
+  // TODO: use result
+  // let results = (outs AnyInteger<GPU_AsyncToken>:$result);
+}
+
+
+def IntOrIndex : AnyTypeOf<[AnyInteger, Index]>;
+
+def Pim_AddOpNew : Pim_Op<"add_new"> {
+  // let arguments = (ins Arg<AnyMemRef, "", [MemRead]>:$lhs,
+  //                      Arg<AnyMemRef, "", [MemRead]>:$rhs);
+  //                      // Arg<Pim_BufferType, "", [MemWrite]>:$result);
+  // let results = (outs Arg<AnyMemRef, "", [MemWrite]>:$result);
+
+  let arguments = (ins Arg<Pim_BufferType, "", [MemRead]>:$lhs,
+                       Arg<Pim_BufferType, "", [MemRead]>:$rhs,
+                       Arg<Pim_BufferType, "", [MemWrite]>:$result);
+  // let results = (outs Arg<Pim_BufferType, "", [MemWrite]>:$result);
+
+
+  // for 3-arg type
+  // let assemblyFormat = "$lhs `,` $rhs  attr-dict `:` $result `(`type($lhs) `,` type($rhs) `:` type($result)`)`";
+  let assemblyFormat = "$lhs `,` $rhs `,` $result  attr-dict `:` `(`type($lhs) `,` type($rhs) `:` type($result)`)`";
+}
+
+def Pim_CreateBufferObject : Pim_Op<"create_buffer"> {
+  // TODO: Need operand converstion pass to specify memrefs (covnert fir ptrs to mlir ptrs)
+  // let arguments = (ins Arg<AnyMemRef, "", [MemRead]>:$obj);
+  let arguments = (ins Arg<AnyType, "", [MemRead]>:$obj,
+                        PimMemType:$mem_type);
+  let results = (outs Pim_BufferType:$result);
+  let assemblyFormat = "$obj attr-dict `:` type($obj) type($result) $mem_type";
+  // %13 = "pim.create_buffer"(%5) : (!fir.ref<!fir.array<10xf16>>) -> !fir.ref<!fir.array<10xf16>>
+}
+
+
+def Pim_UnwrapBufferObject : Pim_Op<"unwrap_buffer"> {
+  let arguments = (ins Arg<Pim_BufferType, "", [MemRead]>:$obj,
+                       Arg<AnyType, "", [MemWrite]>:$result);
+  // let results = (outs AnyType:$result);
+  let assemblyFormat = "$obj $result attr-dict `:` type($obj) type($result)";
+}
+
+def Pim_AddOp : Pim_Op<"add"> {
+  let summary = "pim add operation";
+  // let arguments = (ins VectorOfRankAndType<[2], [F16, I8]>:$input1,
+  //                      VectorOfRankAndType<[2], [F16, I8]>:$input2);
+  // let results = (outs VectorOfRankAndType<[2], [F16, I8]>:$result);
+
+  let arguments = (ins F<16>:$lhs, F<16>:$rhs);
+  let results = (outs F<16>:$result);
+
+  // let arguments = (ins Arg<AnyMemRef, "", [MemRead]>:$lhs, Arg<AnyMemRef, "", [MemRead]>:$rhs);
+  // let results = (outs Arg<AnyMemRef, "", [MemWrite]>:$result);
+
+  let assemblyFormat = "$lhs `,` $rhs  attr-dict `:` type($result)";
+
+  // let builders = [
+  //   OpBuilder<(ins "Value":$element, "Type":$aggregateType),
+  //   [{ build($_builder, $_state, aggregateType, element); }]>];
+
+  // let assemblyFormat = "$input1 `,` $input2  attr-dict `:` type($result)";
+  let hasCustomAssemblyFormat = 1;
+}
+
+def Pim_ParallelOp : Pim_Op<"parallel",
+    [AttrSizedOperandSegments]
+    // TODO(mike): check traits: IsolatedFromAbove,
+    // SingleBlockImplicitTerminator
+    > {
+  let summary = "parallel construct";
+  let description = [{
+    The "pim.parallel" operation represents a parallel construct block. It has
+    one region to be executed in parallel on the current device.
+
+    Example:
+
+    ```mlir
+    pim.parallel {
+      // parallel region
+    }
+    ```
+  }];
+
+  let arguments = (ins Variadic<AnyType>:$copyinOperands,
+                       Variadic<AnyType>:$copyoutOperands,
+                       OptionalAttr<DefaultValueAttr>:$defaultAttr);
+
+  let regions = (region AnyRegion:$region);
+
+  let extraClassDeclaration = [{
+    // static StringRef getLibcallsKeyword() { return "libcalls"; }
+    static StringRef getCopyinKeyword() { return "copyin"; }
+    static StringRef getCopyoutKeyword() { return "copyout"; }
+
+    /// The number of data operands.
+    unsigned getNumDataOperands();
+
+    /// The i-th data operand passed.
+    Value getDataOperand(unsigned i);
+  }];
+  let hasCustomAssemblyFormat = 1;
+}
+
+
+def Pim_InitOp : Pim_Op<"init", [NoSideEffect]> {
+// TODO: specify runtime, data type
+}
+
+def Pim_FInitOp : Pim_Op<"finit", [NoSideEffect]> {
+}
+
+
+// Note that PIMLibrary has INT8 precion type, but no implementation - so do not
+// specify it here for now.
+// def PimFloatType : F<16>;
+
+// def Pim_BufferObjectType : Pim_Type<"Buffer", "buffer"> {
+//   let summary = "Pim buffer type";
+//   let description = [{
+//     TODO
+//   }];
+//   // let parameters = (ins
+// }
+
+
+
+def MEM_FLAG_ELT_OP: I32EnumAttrCase<"ELT_OP", 1>;
+def MEM_FLAG_GEMV_INPUT: I32EnumAttrCase<"GEMV_INPUT", 2>;
+def MEM_FLAG_GEMV_WEIGHT: I32EnumAttrCase<"GEMV_WEIGHT", 3>;
+def MEM_FLAG_GEMV_OUTPUT: I32EnumAttrCase<"GEMV_OUTPUT", 4>;
+def MEM_FLAG_GEMV_WEIGHT_T: I32EnumAttrCase<"GEMV_WEIGHT_T", 5>;
+
+// def Pim_MemFlagType: I32EnumAttr<"MemoryFlag", "Pim memory flag",
+//   [MEM_FLAG_ELT_OP,
+//   MEM_FLAG_GEMV_INPUT,
+//   MEM_FLAG_GEMV_WEIGHT,
+//   MEM_FLAG_GEMV_OUTPUT,
+//   MEM_FLAG_GEMV_WEIGHT_T]> {
+//   let cppNamespace = "pim";
+//   let stringToSymbolFnName = "ConvertToEnum";
+//   let symbolToStringFnName = "ConvertToString";
+// }
+
+#endif // PIM_OPS
diff --git a/mlir/include/mlir/Dialect/Pim/PimOpsInterfaces.td b/mlir/include/mlir/Dialect/Pim/PimOpsInterfaces.td
new file mode 100644
index 000000000000..118154cfb456
--- /dev/null
+++ b/mlir/include/mlir/Dialect/Pim/PimOpsInterfaces.td
@@ -0,0 +1,48 @@
+//===-- PimOpsInterfaces.td - Pim op interfaces ------*- tablegen -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This is the Pim Dialect interfaces definition file.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef Pim_OPS_INTERFACES
+#define Pim_OPS_INTERFACES
+
+include "mlir/IR/OpBase.td"
+
+def OutlineablePimOpInterface : OpInterface<"OutlineablePimOpInterface"> {
+  let description = [{
+    Pim operations whose region will be outlined will implement this
+    interface. These operations will
+  }];
+
+  let cppNamespace = "::mlir::pim";
+
+  let methods = [
+    InterfaceMethod<"Get alloca block", "::mlir::Block*", "getAllocaBlock",
+      (ins), [{
+      return &$_op.getRegion().front();
+      }]>,
+  ];
+}
+
+def ReductionClauseInterface : OpInterface<"ReductionClauseInterface"> {
+  let description = [{
+    Pim operations that support reduction clause have this interface.
+  }];
+
+  let cppNamespace = "::mlir::pim";
+
+  let methods = [
+    InterfaceMethod<
+      "Get reduction vars", "::mlir::SmallVector<::mlir::Value>",
+      "getReductionVars">,
+  ];
+}
+
+#endif // Pim_OPS_INTERFACES
diff --git a/mlir/include/mlir/Dialect/Pim/PimTypeInterfaces.td b/mlir/include/mlir/Dialect/Pim/PimTypeInterfaces.td
new file mode 100644
index 000000000000..85e8d14d43c6
--- /dev/null
+++ b/mlir/include/mlir/Dialect/Pim/PimTypeInterfaces.td
@@ -0,0 +1,31 @@
+//===-- PimTypeInterfaces.td - Pim type interfaces ---*- tablegen -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef PIM_TYPE_INTERFACES
+#define PIM_TYPE_INTERFACES
+
+include "mlir/IR/OpBase.td"
+
+def Pim_PointerLikeTypeInterface : TypeInterface<"PointerLikeType"> {
+  let cppNamespace = "::mlir::pim";
+
+  let description = [{
+    An interface for pointer-like types suitable to contain a value that Pim
+    specification refers to as variable.
+  }];
+
+  let methods = [
+    InterfaceMethod<
+      /*description=*/"Returns the pointee type.",
+      /*retTy=*/"::mlir::Type",
+      /*methodName=*/"getElementType"
+    >,
+  ];
+}
+
+#endif // PIM_TYPE_INTERFACES
diff --git a/mlir/include/mlir/InitAllDialects.h b/mlir/include/mlir/InitAllDialects.h
index 0eceaa18312c..0f7662fa41bb 100644
--- a/mlir/include/mlir/InitAllDialects.h
+++ b/mlir/include/mlir/InitAllDialects.h
@@ -44,6 +44,7 @@
 #include "mlir/Dialect/NVGPU/IR/NVGPUDialect.h"
 #include "mlir/Dialect/OpenACC/OpenACC.h"
 #include "mlir/Dialect/OpenMP/OpenMPDialect.h"
+#include "mlir/Dialect/Pim/PimDialect.h"
 #include "mlir/Dialect/PDL/IR/PDL.h"
 #include "mlir/Dialect/PDLInterp/IR/PDLInterp.h"
 #include "mlir/Dialect/Quant/QuantOps.h"
@@ -93,6 +94,7 @@ inline void registerAllDialects(DialectRegistry &registry) {
                   nvgpu::NVGPUDialect,
                   scf::SCFDialect,
                   omp::OpenMPDialect,
+                  pim::PimDialect,
                   pdl::PDLDialect,
                   pdl_interp::PDLInterpDialect,
                   quant::QuantizationDialect,
diff --git a/mlir/include/mlir/Target/LLVMIR/Dialect/All.h b/mlir/include/mlir/Target/LLVMIR/Dialect/All.h
index 2bbfd7a45d09..521002ed4b0a 100644
--- a/mlir/include/mlir/Target/LLVMIR/Dialect/All.h
+++ b/mlir/include/mlir/Target/LLVMIR/Dialect/All.h
@@ -21,6 +21,7 @@
 #include "mlir/Target/LLVMIR/Dialect/NVVM/NVVMToLLVMIRTranslation.h"
 #include "mlir/Target/LLVMIR/Dialect/OpenACC/OpenACCToLLVMIRTranslation.h"
 #include "mlir/Target/LLVMIR/Dialect/OpenMP/OpenMPToLLVMIRTranslation.h"
+#include "mlir/Target/LLVMIR/Dialect/Pim/PimToLLVMIRTranslation.h"
 #include "mlir/Target/LLVMIR/Dialect/ROCDL/ROCDLToLLVMIRTranslation.h"
 #include "mlir/Target/LLVMIR/Dialect/X86Vector/X86VectorToLLVMIRTranslation.h"
 
@@ -37,6 +38,7 @@ static inline void registerAllToLLVMIRTranslations(DialectRegistry &registry) {
   registerNVVMDialectTranslation(registry);
   registerOpenACCDialectTranslation(registry);
   registerOpenMPDialectTranslation(registry);
+  registerPimDialectTranslation(registry);
   registerROCDLDialectTranslation(registry);
   registerX86VectorDialectTranslation(registry);
 }
diff --git a/mlir/include/mlir/Target/LLVMIR/Dialect/Pim/PimToLLVMIRTranslation.h b/mlir/include/mlir/Target/LLVMIR/Dialect/Pim/PimToLLVMIRTranslation.h
new file mode 100644
index 000000000000..d4a73dbfbdf8
--- /dev/null
+++ b/mlir/include/mlir/Target/LLVMIR/Dialect/Pim/PimToLLVMIRTranslation.h
@@ -0,0 +1,31 @@
+//===- PimToLLVMIRTranslation.h - Pim Dialect to LLVM IR --------*- C++ -*-===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This provides registration calls for Pim dialect to LLVM IR translation.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef MLIR_TARGET_LLVMIR_DIALECT_PIM_PIMTOLLVMIRTRANSLATION_H
+#define MLIR_TARGET_LLVMIR_DIALECT_PIM_PIMTOLLVMIRTRANSLATION_H
+
+namespace mlir {
+
+class DialectRegistry;
+class MLIRContext;
+
+/// Register the Pim dialect and the translation from it to the LLVM IR in
+/// the given registry;
+void registerPimDialectTranslation(DialectRegistry &registry);
+
+/// Register the Pim dialect and the translation from it in the registry
+/// associated with the given context.
+void registerPimDialectTranslation(MLIRContext &context);
+
+} // namespace mlir
+
+#endif // MLIR_TARGET_LLVMIR_DIALECT_PIM_PIMTOLLVMIRTRANSLATION_H
diff --git a/mlir/include/mlir/Target/LLVMIR/ModuleTranslation.h b/mlir/include/mlir/Target/LLVMIR/ModuleTranslation.h
index 3dd0d769007c..b6404470d830 100644
--- a/mlir/include/mlir/Target/LLVMIR/ModuleTranslation.h
+++ b/mlir/include/mlir/Target/LLVMIR/ModuleTranslation.h
@@ -23,6 +23,7 @@
 
 #include "llvm/ADT/SetVector.h"
 #include "llvm/Frontend/OpenMP/OMPIRBuilder.h"
+#include "llvm/Frontend/Pim/PIMIRBuilder.h"
 
 namespace llvm {
 class BasicBlock;
@@ -172,6 +173,17 @@ public:
     return ompBuilder.get();
   }
 
+  /// Returns the Pim IR builder associated with the LLVM IR module being
+  /// constructed.
+  llvm::PIMIRBuilder *getPimBuilder() {
+    if (!ompBuilder) {
+      pimBuilder = std::make_unique<llvm::PIMIRBuilder>(*llvmModule);
+      pimBuilder->initialize();
+    }
+    return pimBuilder.get();
+  }
+
+
   /// Translates the given location.
   const llvm::DILocation *translateLoc(Location loc, llvm::DILocalScope *scope);
 
@@ -299,6 +311,9 @@ private:
   /// Builder for LLVM IR generation of OpenMP constructs.
   std::unique_ptr<llvm::OpenMPIRBuilder> ompBuilder;
 
+  /// Builder for LLVM IR generation of Pim constructs.
+  std::unique_ptr<llvm::PIMIRBuilder> pimBuilder;
+
   /// Mappings between llvm.mlir.global definitions and corresponding globals.
   DenseMap<Operation *, llvm::GlobalValue *> globalsMapping;
 
diff --git a/mlir/lib/Conversion/CMakeLists.txt b/mlir/lib/Conversion/CMakeLists.txt
index 34488e7af9af..4db41ec56746 100644
--- a/mlir/lib/Conversion/CMakeLists.txt
+++ b/mlir/lib/Conversion/CMakeLists.txt
@@ -30,6 +30,7 @@ add_subdirectory(NVGPUToNVVM)
 add_subdirectory(OpenACCToLLVM)
 add_subdirectory(OpenACCToSCF)
 add_subdirectory(OpenMPToLLVM)
+add_subdirectory(PimToLLVM)
 add_subdirectory(PDLToPDLInterp)
 add_subdirectory(ReconcileUnrealizedCasts)
 add_subdirectory(SCFToControlFlow)
diff --git a/mlir/lib/Conversion/PimToLLVM/CMakeLists.txt b/mlir/lib/Conversion/PimToLLVM/CMakeLists.txt
new file mode 100644
index 000000000000..69d1ff21321f
--- /dev/null
+++ b/mlir/lib/Conversion/PimToLLVM/CMakeLists.txt
@@ -0,0 +1,23 @@
+add_mlir_conversion_library(MLIRPimToLLVM
+  PimToLLVM.cpp
+
+  ADDITIONAL_HEADER_DIRS
+  ${MLIR_MAIN_INCLUDE_DIR}/mlir/Conversion/PimToLLVM
+
+  DEPENDS
+  MLIRConversionPassIncGen
+  intrinsics_gen
+
+  LINK_COMPONENTS
+  Core
+
+  LINK_LIBS PUBLIC
+  MLIRArithmeticToLLVM
+  MLIRFuncToLLVM
+  MLIRIR
+  MLIRLLVMCommonConversion
+  MLIRLLVMDialect
+  MLIRMemRefToLLVM
+  MLIRPimDialect
+  MLIRTransforms
+  )
diff --git a/mlir/lib/Conversion/PimToLLVM/PimToLLVM.cpp b/mlir/lib/Conversion/PimToLLVM/PimToLLVM.cpp
new file mode 100644
index 000000000000..9692e3bebaf6
--- /dev/null
+++ b/mlir/lib/Conversion/PimToLLVM/PimToLLVM.cpp
@@ -0,0 +1,127 @@
+//===- PimToLLVM.cpp - conversion from OpenMP to LLVM dialect -------------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+
+#include "mlir/Conversion/PimToLLVM/ConvertPimToLLVM.h"
+
+#include "../PassDetail.h"
+#include "mlir/Conversion/ArithmeticToLLVM/ArithmeticToLLVM.h"
+#include "mlir/Conversion/ControlFlowToLLVM/ControlFlowToLLVM.h"
+#include "mlir/Conversion/FuncToLLVM/ConvertFuncToLLVM.h"
+#include "mlir/Conversion/FuncToLLVM/ConvertFuncToLLVMPass.h"
+#include "mlir/Conversion/LLVMCommon/ConversionTarget.h"
+#include "mlir/Conversion/LLVMCommon/Pattern.h"
+#include "mlir/Conversion/MemRefToLLVM/MemRefToLLVM.h"
+#include "mlir/Dialect/LLVMIR/LLVMDialect.h"
+#include "mlir/Dialect/LLVMIR/LLVMTypes.h"
+#include "mlir/Dialect/Pim/PimDialect.h"
+
+using namespace mlir;
+
+namespace {
+/// A pattern that converts the region arguments in a single-region OpenMP
+/// operation to the LLVM dialect. The body of the region is not modified and is
+/// expected to either be processed by the conversion infrastructure or already
+/// contain ops compatible with LLVM dialect types.
+template <typename OpType>
+struct RegionOpConversion : public ConvertOpToLLVMPattern<OpType> {
+  using ConvertOpToLLVMPattern<OpType>::ConvertOpToLLVMPattern;
+
+  LogicalResult
+  matchAndRewrite(OpType curOp, typename OpType::Adaptor adaptor,
+                  ConversionPatternRewriter &rewriter) const override {
+    auto newOp = rewriter.create<OpType>(
+        curOp.getLoc(), TypeRange(), adaptor.getOperands(), curOp->getAttrs());
+    rewriter.inlineRegionBefore(curOp.region(), newOp.region(),
+                                newOp.region().end());
+    if (failed(rewriter.convertRegionTypes(&newOp.region(),
+                                           *this->getTypeConverter())))
+      return failure();
+
+    rewriter.eraseOp(curOp);
+    return success();
+  }
+};
+
+}
+
+namespace {
+
+template <typename Op>
+class LegalizePimDataOpForLLVMTranslation : public ConvertOpToLLVMPattern<Op> {
+  using ConvertOpToLLVMPattern<Op>::ConvertOpToLLVMPattern;
+
+  LogicalResult
+  matchAndRewrite(Op op, typename Op::Adaptor adaptor,
+                  ConversionPatternRewriter &builder) const override {
+    Location loc = op.getLoc();
+    TypeConverter *converter = ConvertToLLVMPattern::getTypeConverter();
+    const unsigned numDataOperand = op.getNumDataOperands();
+    SmallVector<Value> convertedOperands;
+    for (unsigned idx = 0; idx < numDataOperand; ++idx) {
+      // Note that for now we don't have optional operands for pim constucts, if
+      // this is subject to change - the next line must extract operands at
+      // numOptionalOperands pos (instead of 0)
+      Value originalDataOperand = op.getOperand(idx);
+      if (originalDataOperand.getType().isa<LLVM::LLVMPointerType>()) {
+        convertedOperands.push_back(originalDataOperand);
+      } else if (auto memRefType = originalDataOperand.getType().dyn_cast<MemRefType>()) {
+        Type structType = converter->convertType(memRefType);
+        Value memRefDescriptor = builder.create<UnrealizedConversionCastOp>(
+            loc, structType, originalDataOperand).getResult(0);
+        convertedOperands.push_back(memRefDescriptor);
+      } else {
+        // Type not supported.
+        return builder.notifyMatchFailure(op, "unsupported type");
+      }
+    }
+    builder.replaceOpWithNewOp<Op>(op, TypeRange(), convertedOperands,
+                                   op.getOperation()->getAttrs());
+    return success();
+  }
+};
+} // namespace
+
+namespace {
+struct ConvertPimToLLVMPass
+    : public ConvertPimToLLVMBase<ConvertPimToLLVMPass> {
+  void runOnOperation() override;
+};
+} // namespace
+
+void ConvertPimToLLVMPass::runOnOperation() {
+  auto module = getOperation();
+
+  // Convert to Pim operations with LLVM IR dialect
+  RewritePatternSet patterns(&getContext());
+  LLVMTypeConverter converter(&getContext());
+  arith::populateArithmeticToLLVMConversionPatterns(converter, patterns);
+  cf::populateControlFlowToLLVMConversionPatterns(converter, patterns);
+  populateMemRefToLLVMConversionPatterns(converter, patterns);
+  populateFuncToLLVMConversionPatterns(converter, patterns);
+  populatePimToLLVMConversionPatterns(converter, patterns);
+
+  LLVMConversionTarget target(getContext());
+  // target.addLegalOp<omp::TerminatorOp, omp::TaskyieldOp, omp::FlushOp,
+  //                   omp::BarrierOp, omp::TaskwaitOp>();
+  // configurePimToLLVMConversionLegality(target, converter);
+  if (failed(applyPartialConversion(module, target, std::move(patterns)))) {
+    signalPassFailure();
+  }
+}
+
+void mlir::populatePimToLLVMConversionPatterns(LLVMTypeConverter &converter,
+                                             RewritePatternSet &patterns) {
+
+  patterns.add<LegalizePimDataOpForLLVMTranslation<pim::ParallelOp>>(converter);
+  patterns.add<RegionOpConversion<pim::ParallelOp>>(converter);
+}
+
+
+std::unique_ptr<OperationPass<ModuleOp>> mlir::createConvertPimToLLVMPass() {
+  return std::make_unique<ConvertPimToLLVMPass>();
+}
diff --git a/mlir/lib/Dialect/CMakeLists.txt b/mlir/lib/Dialect/CMakeLists.txt
index 9f84b6211279..69c2da9b3533 100644
--- a/mlir/lib/Dialect/CMakeLists.txt
+++ b/mlir/lib/Dialect/CMakeLists.txt
@@ -20,6 +20,7 @@ add_subdirectory(MLProgram)
 add_subdirectory(NVGPU)
 add_subdirectory(OpenACC)
 add_subdirectory(OpenMP)
+add_subdirectory(Pim)
 add_subdirectory(PDL)
 add_subdirectory(PDLInterp)
 add_subdirectory(Quant)
diff --git a/mlir/lib/Dialect/Pim/CMakeLists.txt b/mlir/lib/Dialect/Pim/CMakeLists.txt
new file mode 100644
index 000000000000..774b27ced6a6
--- /dev/null
+++ b/mlir/lib/Dialect/Pim/CMakeLists.txt
@@ -0,0 +1,15 @@
+add_mlir_dialect_library(MLIRPimDialect
+  IR/Pim.cpp
+
+  ADDITIONAL_HEADER_DIRS
+  ${MLIR_MAIN_INCLUDE_DIR}/mlir/Dialect/Pim
+
+  DEPENDS
+  MLIRPimOpsIncGen
+  # MLIRPimOpsInterfacesIncGen
+  # MLIRPimTypeInterfacesIncGen
+
+  LINK_LIBS PUBLIC
+  MLIRIR
+  )
+
diff --git a/mlir/lib/Dialect/Pim/IR/Pim.cpp b/mlir/lib/Dialect/Pim/IR/Pim.cpp
new file mode 100644
index 000000000000..4b78f237726b
--- /dev/null
+++ b/mlir/lib/Dialect/Pim/IR/Pim.cpp
@@ -0,0 +1,287 @@
+//===- Pim.cpp - PIM MLIR Operations ------_-------------------------------===//
+//
+// Part of the MLIR Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+// =============================================================================
+
+#include "mlir/Dialect/Pim/Pim.h"
+#include "mlir/Dialect/Pim/PimOpsEnums.cpp.inc"
+#include "mlir/IR/Builders.h"
+#include "mlir/IR/BuiltinTypes.h"
+#include "mlir/IR/DialectImplementation.h"
+#include "mlir/IR/Matchers.h"
+#include "mlir/IR/OpImplementation.h"
+#include "mlir/IR/Types.h"
+#include "mlir/Support/LLVM.h"
+#include "mlir/Transforms/DialectConversion.h"
+#include "llvm/ADT/TypeSwitch.h"
+
+
+#include "llvm/Support/Debug.h"
+
+#define DEBUG_TYPE "pim-mlir-ir"
+
+using namespace mlir;
+using namespace pim;
+
+
+#define GET_TYPEDEF_CLASSES
+#include "mlir/Dialect/Pim/PimOpsTypes.cpp.inc"
+
+#include "mlir/Dialect/Pim/PimOpsDialect.cpp.inc"
+
+void mlir::pim::PimDialect::initialize() {
+  addOperations<
+#define GET_OP_LIST
+#include "mlir/Dialect/Pim/PimOps.cpp.inc"
+      >();
+  addAttributes<
+#define GET_ATTRDEF_LIST
+#include "mlir/Dialect/Pim/PimOpsAttributes.cpp.inc"
+      >();
+  addTypes<
+#define GET_TYPEDEF_LIST
+#include "mlir/Dialect/Pim/PimOpsTypes.cpp.inc"
+      >();
+}
+
+
+template <typename StructureOp>
+static ParseResult parseRegions(OpAsmParser &parser, OperationState &state,
+                                unsigned nRegions = 1) {
+
+  SmallVector<Region *, 2> regions;
+  for (unsigned i = 0; i < nRegions; ++i)
+    regions.push_back(state.addRegion());
+
+  for (Region *region : regions) {
+    if (parser.parseRegion(*region, /*arguments=*/{}, /*argTypes=*/{}))
+      return failure();
+  }
+
+  return success();
+}
+
+static ParseResult
+parseOperandList(OpAsmParser &parser, StringRef keyword,
+                 SmallVectorImpl<OpAsmParser::UnresolvedOperand> &args,
+                 SmallVectorImpl<Type> &argTypes, OperationState &result) {
+  if (failed(parser.parseOptionalKeyword(keyword)))
+    return success();
+
+  if (failed(parser.parseLParen()))
+    return failure();
+
+  // Exit early if the list is empty.
+  if (succeeded(parser.parseOptionalRParen()))
+    return success();
+
+  if (failed(parser.parseCommaSeparatedList([&]() {
+        OpAsmParser::UnresolvedOperand arg;
+        Type type;
+
+        if (parser.parseOperand(arg, /*allowResultNumber=*/false) ||
+            parser.parseColonType(type))
+          return failure();
+
+        args.push_back(arg);
+        argTypes.push_back(type);
+        return success();
+      })) ||
+      failed(parser.parseRParen()))
+    return failure();
+
+  return parser.resolveOperands(args, argTypes, parser.getCurrentLocation(),
+                                result.operands);
+}
+
+static void printOperandList(Operation::operand_range operands,
+                             StringRef listName, OpAsmPrinter &printer) {
+
+  if (!operands.empty()) {
+    printer << " " << listName << "(";
+    llvm::interleaveComma(operands, printer, [&](Value op) {
+      printer << op << ": " << op.getType();
+    });
+    printer << ")";
+  }
+}
+
+// ParseResult ParallelOp::parse(OpAsmParser &parser, OperationState &result) {
+//   Builder &builder = parser.getBuilder();
+//   SmallVector<OpAsmParser::UnresolvedOperand, 2> copyinOperands, copyoutOperands;
+//   SmallVector<Type, 2> copyinOperandTypes, copyoutOperandTypes;
+
+//   // SmallVector<Type, 8> operandTypes;
+//   // OpAsmParser::UnresolvedOperand ifCond, selfCond;
+//   // bool hasIfCond = false, hasSelfCond = false;
+//   // OptionalParseResult async, numGangs, numWorkers, vectorLength;
+//   // Type i1Type = builder.getI1Type();
+
+//   // libcalls()?
+//   // if (failed(parseOperandList(parser, ParallelOp::getLibcallsKeyword(),
+//   //                             libcallsOperands, libcallsOperandTypes, result)))
+//   //   return failure();
+
+//   // copyin()?
+//   if (failed(parseOperandList(parser, ParallelOp::getCopyinKeyword(),
+//                               copyinOperands, copyinOperandTypes, result)))
+//     return failure();
+
+//   // copyout()?
+//   if (failed(parseOperandList(parser, ParallelOp::getCopyoutKeyword(),
+//                               copyoutOperands, copyoutOperandTypes, result)))
+//     return failure();
+
+//     LLVM_DEBUG({
+//         llvm::errs() << "BEFORE Parallel op region parse\n";
+//     });
+
+//   // Parallel op region
+//   if (failed(parseRegions<ParallelOp>(parser, result)))
+//     return failure();
+
+//     LLVM_DEBUG({
+//         llvm::errs() << "copyinOperands.size() :" << copyinOperands.size() << "\n";
+//         llvm::errs() << "copyoutOperands.size() :" << copyoutOperands.size() << "\n";
+//     });
+
+//   result.addAttribute(ParallelOp::getOperandSegmentSizeAttr(),
+//                       builder.getDenseI32ArrayAttr({
+//                           // static_cast<int32_t>(libcallsOperands.size()),
+//                           static_cast<int32_t>(copyinOperands.size()),
+//                           static_cast<int32_t>(copyoutOperands.size()),
+//                       }));
+
+//   // Additional attributes
+//   if (failed(parser.parseOptionalAttrDictWithKeyword(result.attributes)))
+//     return failure();
+
+//     LLVM_DEBUG(llvm::errs() << "ParallelOP DONE\n");
+
+//   return success();
+// }
+
+// void ParallelOp::print(OpAsmPrinter &printer) {
+//   // printOperandList(libcallsOperands(), ParallelOp::getLibcallsKeyword(), printer);
+//   printOperandList(copyinOperands(), ParallelOp::getCopyinKeyword(), printer);
+//   printOperandList(copyoutOperands(), ParallelOp::getCopyoutKeyword(), printer);
+
+//   printer << ' ';
+//   printer.printRegion(region(),
+//                       /*printEntryBlockArgs=*/false,
+//                       /*printBlockTerminators=*/true);
+//   printer.printOptionalAttrDictWithKeyword(
+//       (*this)->getAttrs(), ParallelOp::getOperandSegmentSizeAttr());
+// }
+
+// ::mlir::Attribute PimDialect::parseAttribute(::mlir::DialectAsmParser &parser,
+//                                              ::mlir::Type type) const {
+//   return {};
+// }
+
+// /// Print an attribute registered to this dialect.
+// void PimDialect::printAttribute(::mlir::Attribute attr,
+//                                 ::mlir::DialectAsmPrinter &os) const {
+//   // return;
+// }
+
+// ld.lld: error: undefined symbol: mlir::pim::PimDialect::printAttribute(mlir::Attribute, mlir::DialectAsmPrinter&) const
+
+
+ParseResult ParallelOp::parse(OpAsmParser &parser, OperationState &result) {
+  Builder &builder = parser.getBuilder();
+  SmallVector<OpAsmParser::UnresolvedOperand, 8> copyinOperands, copyoutOperands;
+  SmallVector<Type, 8> copyinOperandTypes, copyoutOperandTypes;
+
+
+  // copyin()?
+  if (failed(parseOperandList(parser, ParallelOp::getCopyinKeyword(),
+                              copyinOperands, copyinOperandTypes, result)))
+    return failure();
+
+  // copyout()?
+  if (failed(parseOperandList(parser, ParallelOp::getCopyoutKeyword(),
+                              copyoutOperands, copyoutOperandTypes, result)))
+    return failure();
+  // Parallel op region
+  if (failed(parseRegions<ParallelOp>(parser, result)))
+    return failure();
+
+  result.addAttribute(ParallelOp::getOperandSegmentSizeAttr(),
+                      builder.getDenseI32ArrayAttr(
+                          {static_cast<int32_t>(copyinOperands.size()),
+                           static_cast<int32_t>(copyoutOperands.size())}));
+
+  // Additional attributes
+  if (failed(parser.parseOptionalAttrDictWithKeyword(result.attributes)))
+    return failure();
+
+  return success();
+}
+
+void ParallelOp::print(OpAsmPrinter &printer) {
+
+  // copyin()?
+  printOperandList(copyinOperands(), ParallelOp::getCopyinKeyword(), printer);
+
+  // copyout()?
+  printOperandList(copyoutOperands(), ParallelOp::getCopyoutKeyword(), printer);
+
+  printer << ' ';
+  printer.printRegion(region(),
+                      /*printEntryBlockArgs=*/false,
+                      /*printBlockTerminators=*/true);
+  printer.printOptionalAttrDictWithKeyword(
+      (*this)->getAttrs(), ParallelOp::getOperandSegmentSizeAttr());
+}
+
+// void AddOp::print(OpAsmPrinter &printer) {
+//   printer << "add ";
+//   printer << ' ';
+//   printer.printOptionalAttrDictWithKeyword(
+//       (*this)->getAttrs(), ParallelOp::getOperandSegmentSizeAttr());
+// }
+
+// ParseResult AddOp::parse(OpAsmParser &parser, OperationState &result) {
+//   Builder &builder = parser.getBuilder();
+//   SmallVector<OpAsmParser::UnresolvedOperand, 8> copyinOperands, copyoutOperands;
+//   SmallVector<Type, 8> copyinOperandTypes, copyoutOperandTypes;
+
+
+//   // copyin()?
+//   if (failed(parseOperandList(parser, ParallelOp::getCopyinKeyword(),
+//                               copyinOperands, copyinOperandTypes, result)))
+//     return failure();
+
+//   // copyout()?
+//   if (failed(parseOperandList(parser, ParallelOp::getCopyoutKeyword(),
+//                               copyoutOperands, copyoutOperandTypes, result)))
+//     return failure();
+//   // Parallel op region
+//   if (failed(parseRegions<ParallelOp>(parser, result)))
+//     return failure();
+
+//   result.addAttribute(ParallelOp::getOperandSegmentSizeAttr(),
+//                       builder.getDenseI32ArrayAttr(
+//                           {static_cast<int32_t>(copyinOperands.size()),
+//                            static_cast<int32_t>(copyoutOperands.size())}));
+
+//   // Additional attributes
+//   if (failed(parser.parseOptionalAttrDictWithKeyword(result.attributes)))
+//     return failure();
+
+//   return success();
+// }
+
+unsigned ParallelOp::getNumDataOperands() {
+  return copyinOperands().size() + copyoutOperands().size();
+}
+
+#define GET_OP_CLASSES
+#include "mlir/Dialect/Pim/PimOps.cpp.inc"
+
+#define GET_ATTRDEF_CLASSES
+#include "mlir/Dialect/Pim/PimOpsAttributes.cpp.inc"
diff --git a/mlir/lib/Target/LLVMIR/CMakeLists.txt b/mlir/lib/Target/LLVMIR/CMakeLists.txt
index 3ee83820b1e2..72e7a25415c3 100644
--- a/mlir/lib/Target/LLVMIR/CMakeLists.txt
+++ b/mlir/lib/Target/LLVMIR/CMakeLists.txt
@@ -24,6 +24,7 @@ add_mlir_translation_library(MLIRTargetLLVMIRExport
   LINK_COMPONENTS
   Core
   FrontendOpenMP
+  FrontendPIM
   TransformUtils
 
   LINK_LIBS PUBLIC
@@ -45,6 +46,7 @@ add_mlir_translation_library(MLIRToLLVMIRTranslationRegistration
   MLIRNVVMToLLVMIRTranslation
   MLIROpenACCToLLVMIRTranslation
   MLIROpenMPToLLVMIRTranslation
+  MLIRPimToLLVMIRTranslation
   MLIRROCDLToLLVMIRTranslation
   )
 
diff --git a/mlir/lib/Target/LLVMIR/Dialect/CMakeLists.txt b/mlir/lib/Target/LLVMIR/Dialect/CMakeLists.txt
index 8df5176ad056..8b1c8c0f2fab 100644
--- a/mlir/lib/Target/LLVMIR/Dialect/CMakeLists.txt
+++ b/mlir/lib/Target/LLVMIR/Dialect/CMakeLists.txt
@@ -5,5 +5,6 @@ add_subdirectory(LLVMIR)
 add_subdirectory(NVVM)
 add_subdirectory(OpenACC)
 add_subdirectory(OpenMP)
+add_subdirectory(Pim)
 add_subdirectory(ROCDL)
 add_subdirectory(X86Vector)
diff --git a/mlir/lib/Target/LLVMIR/Dialect/Pim/CMakeLists.txt b/mlir/lib/Target/LLVMIR/Dialect/Pim/CMakeLists.txt
new file mode 100644
index 000000000000..72e9a2ed332c
--- /dev/null
+++ b/mlir/lib/Target/LLVMIR/Dialect/Pim/CMakeLists.txt
@@ -0,0 +1,13 @@
+add_mlir_translation_library(MLIRPimToLLVMIRTranslation
+  PimToLLVMIRTranslation.cpp
+
+  LINK_COMPONENTS
+  Core
+
+  LINK_LIBS PUBLIC
+  MLIRIR
+  MLIRLLVMDialect
+  MLIRPimDialect
+  MLIRSupport
+  MLIRTargetLLVMIRExport
+  )
diff --git a/mlir/lib/Target/LLVMIR/Dialect/Pim/PimToLLVMIRTranslation.cpp b/mlir/lib/Target/LLVMIR/Dialect/Pim/PimToLLVMIRTranslation.cpp
new file mode 100644
index 000000000000..8d3110e87cc9
--- /dev/null
+++ b/mlir/lib/Target/LLVMIR/Dialect/Pim/PimToLLVMIRTranslation.cpp
@@ -0,0 +1,98 @@
+//===- PimToLLVMIRTranslation.cpp - Translate Pim dialect to LLVM IR ------===//
+//
+// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
+// See https://llvm.org/LICENSE.txt for license information.
+// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
+//
+//===----------------------------------------------------------------------===//
+//
+// This file implements a translation between the MLIR Pim dialect and LLVM
+// IR.
+//
+//===----------------------------------------------------------------------===//
+#include "mlir/Target/LLVMIR/Dialect/Pim/PimToLLVMIRTranslation.h"
+#include "mlir/Conversion/PimToLLVM/ConvertPimToLLVM.h"
+#include "mlir/IR/BlockAndValueMapping.h"
+#include "mlir/Dialect/Pim/Pim.h"
+#include "mlir/IR/Operation.h"
+#include "mlir/Support/LLVM.h"
+#include "mlir/Target/LLVMIR/ModuleTranslation.h"
+
+#include "llvm/ADT/SetVector.h"
+#include "llvm/ADT/TypeSwitch.h"
+#include "llvm/Frontend/Pim/PIMIRBuilder.h"
+#include "llvm/IR/DebugInfoMetadata.h"
+#include "llvm/IR/IRBuilder.h"
+
+using namespace mlir;
+
+/// Converts the Pim parallel operation to LLVM IR.
+static LogicalResult
+convertPimParallel(llvm::IRBuilderBase &builder,
+                   LLVM::ModuleTranslation &moduleTranslation) {
+  builder.restoreIP(
+      moduleTranslation.getPimBuilder()->createParallel(builder.saveIP()));
+  return success();
+}
+
+
+namespace {
+
+
+/// Implementation of the dialect interface that converts operations belonging
+/// to the Pim dialect to LLVM IR.
+class PimDialectLLVMIRTranslationInterface
+    : public LLVMTranslationDialectInterface {
+public:
+  using LLVMTranslationDialectInterface::LLVMTranslationDialectInterface;
+
+  /// Translates the given operation to LLVM IR using the provided IR builder
+  /// and saving the state in `moduleTranslation`.
+  LogicalResult
+  convertOperation(Operation *op, llvm::IRBuilderBase &builder,
+                   LLVM::ModuleTranslation &moduleTranslation) const final;
+};
+
+} // namespace
+
+/// Given an Pim MLIR operation, create the corresponding LLVM IR
+/// (including Pim runtime calls).
+LogicalResult PimDialectLLVMIRTranslationInterface::convertOperation(
+    Operation *op, llvm::IRBuilderBase &builder,
+    LLVM::ModuleTranslation &moduleTranslation) const {
+  llvm::PIMIRBuilder *pimBuilder = moduleTranslation.getPimBuilder();
+  return llvm::TypeSwitch<Operation *, LogicalResult>(op)
+      .Case([&](pim::ParallelOp parallelOp) {
+        return convertPimParallel(builder, moduleTranslation);
+      })
+      .Case([&](pim::SumOp sumOp) {
+        llvm::Value *input1 = moduleTranslation.lookupValue(sumOp.lhs());
+        llvm::Value *input2 = moduleTranslation.lookupValue(sumOp.rhs());
+        llvm::Value *result = moduleTranslation.lookupValue(sumOp.result());
+        pimBuilder->createAdd(input1, input2, result);
+        // return convertPimSum(*op, builder, moduleTranslation);
+        return success();
+      })
+    .Case([&](pim::YieldOp yieldOp) {
+      // .Case([&](pim::FlushOp) {
+        pimBuilder->createYield(builder.saveIP());
+        return success();
+      })
+      .Default([&](Operation *inst) {
+        return inst->emitError("unsupported Pim operation: ")
+               << inst->getName();
+      });
+}
+
+void mlir::registerPimDialectTranslation(DialectRegistry &registry) {
+  registry.insert<pim::PimDialect>();
+  registry.addExtension(+[](MLIRContext *ctx, pim::PimDialect *dialect) {
+    dialect->addInterfaces<PimDialectLLVMIRTranslationInterface>();
+  });
+}
+
+void mlir::registerPimDialectTranslation(MLIRContext &context) {
+  DialectRegistry registry;
+  registerPimDialectTranslation(registry);
+  context.appendDialectRegistry(registry);
+}
diff --git a/mlir/lib/Target/LLVMIR/ModuleTranslation.cpp b/mlir/lib/Target/LLVMIR/ModuleTranslation.cpp
index 4855571c05bd..af11f75fd72f 100644
--- a/mlir/lib/Target/LLVMIR/ModuleTranslation.cpp
+++ b/mlir/lib/Target/LLVMIR/ModuleTranslation.cpp
@@ -30,6 +30,7 @@
 #include "llvm/ADT/PostOrderIterator.h"
 #include "llvm/ADT/SetVector.h"
 #include "llvm/Frontend/OpenMP/OMPIRBuilder.h"
+#include "llvm/Frontend/Pim/PIMIRBuilder.h"
 #include "llvm/IR/BasicBlock.h"
 #include "llvm/IR/CFG.h"
 #include "llvm/IR/Constants.h"
-- 
2.17.1

